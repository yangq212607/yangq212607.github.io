<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[刷算法(3)-字符串的编码与解码]]></title>
    <url>%2Fpost%2F82cdd3db.html</url>
    <content type="text"><![CDATA[271.字符串的编码与解码设计一个算法，可以将一个 字符串列表 编码成为一个 字符串。这个编码后的字符串是可以通过网络进行高效传送的，并且可以在接收端被解码回原来的字符串列表。 思路猛一看题目很简单以为简单的拼接起来，中间加个分隔符就行了，但是输入字符串本身可能就是分隔符。所以必须还要加上长度信息，我们的加码方法是长度+”/“+字符串，比如对于”a”,”ab”,”abc”，我们就变成”1/a2/ab3/abc”，那么我们解码的时候就有规律可寻，先寻找”/“，然后之前的就是要取出的字符个数，从“/“后取出相应个数即可，以此类推直至没有”/“了。编码方法是这样，具体解码又以下三种思路。 解法1用一个索引i来标记从哪一位开始搜索分隔符，搜索到之后截出来前面的长度信息，根据长度信息再截出来对应字符串。之后把i往后移，重新开始搜索分隔符。代码如下: 12345678910111213141516171819202122232425262728293031323334package com.company;import java.util.ArrayList;import java.util.List;public class Codec1 &#123; // Encodes a list of strings to a single string. public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String item : strs) &#123; int length = item.length(); sb.append(length).append(&quot;/&quot;).append(item); &#125; return sb.toString(); &#125; // Decodes a single string to a list of strings. public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); int i = 0; while (i &lt; s.length()) &#123; int pos = s.indexOf(&apos;/&apos;, i); int itemSize = Integer.parseInt(s.substring(i, pos)); int start = pos + 1; int end = pos + itemSize + 1; if (end &lt;= s.length()) &#123; String item = s.substring(start, end); result.add(item); &#125; i = end; &#125; return result; &#125;&#125; 解法2和解法1类似，区别在于我们每次可以从原始输入s里把对应item截出来后重新赋值，之后从裁剪后的s继续遍历，直到s为空。 12345678910111213141516171819202122232425package com.company;import java.util.ArrayList;import java.util.List;public class Codec2 &#123; public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String item : strs) &#123; sb.append(item.length()).append(&quot;/&quot;).append(item); &#125; return sb.toString(); &#125; public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); while (!s.isEmpty()) &#123; int pos = s.indexOf(&quot;/&quot;); int itemSize = Integer.parseInt(s.substring(0, pos)); result.add(s.substring(pos + 1, pos + itemSize + 1)); s = s.substring(pos + itemSize + 1); &#125; return result; &#125;&#125; 解法3我们可以编码的时候通过Java里的换行符\n进行分割，读入时借助BufferReader逐行读取就行了。 12345678910111213141516171819202122232425262728293031package com.company;import java.io.BufferedReader;import java.io.StringReader;import java.util.ArrayList;import java.util.List;public class Codec &#123; public String encode(List&lt;String&gt; strs) &#123; StringBuilder sb = new StringBuilder(); for (String item : strs) &#123; sb.append(item).append(&apos;\n&apos;); &#125; return sb.toString(); &#125; public List&lt;String&gt; decode(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); BufferedReader br = new BufferedReader(new StringReader(s)); String temp = null; try &#123; while ((temp = br.readLine()) != null) &#123; result.add(temp); &#125; &#125; catch (Exception e) &#123; &#125; return result; &#125;&#125; 三种方法对比 解法 耗时 内存 解法1 7ms 39.3MB 解法2 15ms 39.8MB 解法3 23ms 38.7MB String基础操作indexOf从左往右查找第一次出现x的索引，如果不出现则返回-1。 1234567891011121314151617/** * Returns the index within this string of the first occurrence of the * specified substring. * * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the first occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */public int indexOf(String str) &#123; return indexOf(str, 0);&#125; 其中indexOf(str, 0)原型如下： 1234567891011121314151617181920/** * Returns the index within this string of the first occurrence of the * specified substring, starting at the specified index. * * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * &lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index from which to start the search. * @return the index of the first occurrence of the specified substring, * starting at the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex);&#125; fromIndex表示开始搜索的地方，是算在数的。 lastIndexOf从最后面开始找第一次出现x的索引，索引位置还是从正向开始计算的。 123456789101112131415161718192021222324252627282930313233343536373839/** * Returns the index within this string of the last occurrence of the * specified substring. The last occurrence of the empty string &quot;&quot; * is considered to occur at the index value &#123;@code this.length()&#125;. * * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the last occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length); &#125; /** * Returns the index within this string of the last occurrence of the * specified substring, searching backward starting at the specified index. * * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * &lt;i&gt;k&lt;/i&gt; &#123;@code &lt;=&#125; fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index to start the search from. * @return the index of the last occurrence of the specified substring, * searching backward from the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; 总结：indexOf和lastIndexOf里第二个位置参数是参与搜索的。 substringsubstring(int beginIndex, int endIndex)截取的是从beginIndex开始到endIndex-1的字符串，截出来的长度为endIndex-beginIndex。 123456789101112131415161718192021222324252627282930313233343536/** * Returns a string that is a substring of this string. The * substring begins at the specified &#123;@code beginIndex&#125; and * extends to the character at index &#123;@code endIndex - 1&#125;. * Thus the length of the substring is &#123;@code endIndex-beginIndex&#125;. * &lt;p&gt; * Examples: * &lt;blockquote&gt;&lt;pre&gt; * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot; * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot; * &lt;/pre&gt;&lt;/blockquote&gt; * * @param beginIndex the beginning index, inclusive. * @param endIndex the ending index, exclusive. * @return the specified substring. * @exception IndexOutOfBoundsException if the * &#123;@code beginIndex&#125; is negative, or * &#123;@code endIndex&#125; is larger than the length of * this &#123;@code String&#125; object, or * &#123;@code beginIndex&#125; is larger than * &#123;@code endIndex&#125;. */ public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; 参考 https://github.com/grandyang/leetcode/issues/271 JAVA中String字符串的各种基本操作]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷算法(2)-反转字符串]]></title>
    <url>%2Fpost%2Fc101f8b.html</url>
    <content type="text"><![CDATA[题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组char[]的形式给出。 题解(折半遍历)12345678public void reverseString(char[] s) &#123; int length = s.length; for (int i = 0, j = length -1; i &lt;= j; i++, j--) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo配置汇总]]></title>
    <url>%2Fpost%2Fb4cfac7b.html</url>
    <content type="text"><![CDATA[简介本文介绍hexo使用、维护、升级配置汇总，theme为next-theme。 升级hexo从3.8.0至3.9.0升级前运行hexo version查看版本信息如下： 123456789101112131415161718➜ hexo git:(master) hexo versionhexo: 3.8.0hexo-cli: 1.1.0os: Darwin 18.6.0 darwin x64http_parser: 2.8.0node: 10.15.3v8: 6.8.275.32-node.51uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 升级hexo-cli执行：sudo npm install hexo-cli -g 升级hexo执行：npm install hexo --save升级之后可以手动将package.json里的hexo对应version改下。执行完毕后如下： 升级package.json其他依赖，这个方法有三种： 手工更新(先改package里的版本号)在http://npm.taobao.org/package/hexo-deployer-git里手动检查每个dependencies，如hexo-deployer-git本来版本号是^0.3.1是没法升到最新的2.0.0的。手动修改package.json里的hexo-deployer-git为^2.0.0,然后输入:npm install hexo-deployer-git --save 手工更新(npm update命令)npm update hexo-deployer-git@2.0.0 --save或者:npm update hexo-deployer-git@latest --save 通过npm-check-updates执行：npm install -g npm-check-updates安装，之后ncu就是这个命令缩写。执行：ncu检查更新如下： 执行：ncu -u更新package.json文件： 最后通过npm install安装更新。 升级hexo-next-theme从7.1.0至7.4.0下载最新版本参考官网安装指导，选择方式1，在hexo博客根目录下执行： 1curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1` 头像如果自己的头像使用git仓文件的话，将对应图片如avatar.jpg放在next的images文件夹下，随后在下面的配置里设上。 解耦个性化配置hexo3.5以上版本next-theme的配置文件都在自己主题下的_config.yml，为了让个性化配置和源码里解耦方便后续升级主题，新建source/_data/next.yml，内容从next/_config.yml里完整拷贝过来。同时在默认的next/_config.yml里将override: false，表示如果有冲突时会merge自定义的next.yml和默认的_config.yml，以next.yml为准。这样next.yml只保留自己个性化定制的东西即可。 头像：avatar的URL字段设置为images/avatar.jpg 个数统计，使用busuanzi_count gitalk评论 Menu Settings Scheme Settings footer设置since和icon 字体设置升到最新的7.4.0后发现字体特别大不好看，修改font settings使用Noto Serif SC思源宋体大小为默认的0.8刚刚好： 123456789101112131415161718font: # Use custom fonts families or not. # Depended options: `external` and `family`. enable: true # Uri of fonts host, e.g. //fonts.googleapis.com (Default). host: https://fonts.loli.net # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside &lt;body&gt;. global: external: true family: Noto Serif SC size: 0.8 代码高亮设置配置： 123456789101112codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright # See: https://github.com/chriskempson/tomorrow-theme highlight_theme: night bright # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: default 然后还要将https://github.com/chriskempson/tomorrow-theme.git拷贝到theme/next/source/lib下才会生效。 CNAME解决github 404问题需要在主题的themes/next_7.4.0/source的目录下新建 CNAME 文件，内容为自己的域名，本文为: 1yangq.me 否则每次push到github后，将会遇到404问题。然后需要在github的仓pages设置里把域名设进去。下次push后又会遇到404问题，需要再次设置。通过CNAME文件解决此问题。 搜索功能之前一直使用的Algolia，但是发现不太好用，一段时间之后再搜索就不灵了。这次采用的是Local Search ，简单好用而且不收费。 安装hexo-generator-searchdb，站点根目录下执行: 1npm install hexo-generator-searchdb --save 然后站点配置文件新增: 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能: 12local_search: enable: true 参考 npm 更新package.json Hexo Theme NexT 主题个性化配置最佳实践 Next修改字体]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷算法(1)-两数之和]]></title>
    <url>%2Fpost%2Fa28dc3f0.html</url>
    <content type="text"><![CDATA[题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 第一种做法：暴力破解1234567891011121314151617package com.yangq.test;public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] results = new int[] &#123;0, 0&#125;; for (int i =0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; results[0] = i; results[1] = j; &#125; &#125; &#125; return results; &#125;&#125; 时间复杂度：O(n^2)，空间复杂度O(1)。 第二种做法:一遍哈希1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; data = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i&lt; nums.length; i++) &#123; int diff = target - nums[i]; if (data.containsKey(diff)) &#123; return new int[] &#123;i, data.get(diff)&#125;; &#125; data.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;can&apos;t found&quot;); &#125;&#125; 时间复杂度：O(n)，我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。 空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[V2Ray纪要]]></title>
    <url>%2Fpost%2F186c438c.html</url>
    <content type="text"><![CDATA[本文介绍V2Ray科学上网新姿势。 服务端以下所有命令均需要以root权限进行: 123wget https://install.direct/go.shchmod +x go.shbash go.sh 查看配置文件： 1vim /etc/v2ray/config.json 记下inbounds里的port、clients里的id和alterId三个变量即可： 12345678910111213141516171819202122232425262728293031323334&quot;inbounds&quot;: [ &#123; &quot;port&quot;: 8012, &quot;protocol&quot;: &quot;vmess&quot;, &quot;settings&quot;: &#123; &quot;clients&quot;: [ &#123; &quot;id&quot;: &quot;4f89d776-4ba8-4d5d-a211-9db5a948***&quot;, &quot;level&quot;: 1, &quot;alterId&quot;: 233 &#125; ] &#125;, &quot;streamSettings&quot;: &#123; &quot;wsSettings&quot;:&#123; &quot;path&quot;:&quot;/&quot;, &quot;headers&quot;:&#123;&#125; &#125;, &quot;network&quot;: &quot;tcp&quot; &#125;, &quot;sniffing&quot;: &#123; &quot;enabled&quot;: true, &quot;destOverride&quot;: [ &quot;http&quot;, &quot;tls&quot; ] &#125; &#125; //include_ss //include_socks //include_mtproto //include_in_config // ] 其中的id、alterId、port及协议类型vmess需要和客户端对应，尤其是streamSettings里的network，这里是tcp也需要和客户端对应。 客户端(Mac)本文介绍三种安装方式，推荐使用带图形界面的第三种方式。无论哪种方式对客户端来说把outbounds配置好就行了，该字段又对应服务端的inbounds。 1.brew方式安装https://github.com/v2ray/homebrew-v2ray 12345brew tap v2ray/v2raybrew install v2ray-corebrew updatebrew upgrade v2ray-corebrew uninstall v2ray-core 修改配置: 12vim /usr/local/etc/v2ray/config.jsonbrew services run v2ray-core 也可以通过brew services start v2ray-core开机运行v2ray。 2.二进制安装https://github.com/v2ray/dist/缺点是要自己手动启动，并修改配置文件： 12345678910111213141516171819&quot;outbounds&quot;: [ &#123; &quot;protocol&quot;: &quot;vmess&quot;, // 出口协议 &quot;settings&quot;: &#123; &quot;vnext&quot;: [ &#123; &quot;address&quot;: &quot;67.218.**.**&quot;, // 服务器地址，请修改为你自己的服务器 IP 或域名 &quot;port&quot;: 41254, // 服务器端口 &quot;users&quot;: [ &#123; &quot;id&quot;: &quot;4f89d776-4ba8-4d5d-a211-9db5a94*****&quot;, // 用户 ID，必须与服务器端配置相同 &quot;alterId&quot;: 233// 此处的值也应当与服务器相同 &#125; ] &#125; ] &#125; &#125; ] 3.GUI软件(Android、iOS、Mac、Windows)参考v2ray神一样的工具,我使用的是V2RayX,下载后直接配置就好。重点关注红框里的信息，其中Address、Port、UserId、alterId、Network需要和服务端的inbounds字段严格对应。 其他平台: V2RayW-windows Kitsunebi-Android websocket+tls+web通过上面的配置安装已经可以实现科学上网了，下面介绍把CDN也加上实现更安全的方式。需要买一个域名并配置dns转发到目的IP。这样所有科学上网的端侧请求目的不再是IP，而是一个域名，经过转发后才访问对应的目的I，最终实现被墙了的IP也能访问的目的。要实现这一步你需要有以下几个东西： 一个域名，可以在https://www.namesilo.com/ 购买更便宜。 一个CDN中转解析域名的东西，推荐使用https://www.cloudflare.com/ 一个墙外的VPS,在上面搭建好v2ray VPS上安装Caddy或Nginx,实现Web+TLS 参考 https://toutyrater.github.io/prep/install.html 官网教程 v2ray+CloudFlare 基于v2ray的websocket+tls+web实现安全网络代理 debian8开启BBR 233body]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python批量push多个仓至github]]></title>
    <url>%2Fpost%2F6d48edea.html</url>
    <content type="text"><![CDATA[简介本文记录使用Python批量从bare类型的git仓库上push到bitbucket. python代码废话不说，先来看代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2018/5/20 下午12:50# @Site : # @File : main.py# @Software: PyCharm Community Editionimport osdef main(): DIR = &apos;/Users/yanzi/work/git/xxx-android-framework&apos; if not os.path.exists(DIR): print(&apos;error: %s not exist&apos; % DIR) return if os.path.isfile(DIR): print(&apos;error: %s is not dir&apos; % DIR) return dirs = os.listdir(DIR) PATH = [] REPO = [] i = 0 for git in dirs: if str(git).endswith(&apos;.git&apos;): # if i == 3: # break PATH = getPath(DIR, git) pushRepo(PATH, git) i += 1 #遍历文件夹DIR # for (root, dirs, files) in os.walk(DIR): # if root == DIR: # print(dirs) # breakdef getPath(dir, git): return dir + &apos;/&apos; + gitdef getRepo(git): return git[:-4]def pushRepo(path, git): os.chdir(path) pushCmd = &apos;git push --mirror git@bitbucket.org:xxx/&apos; + git print(pushCmd) os.system(pushCmd)if __name__ == &apos;__main__&apos;: main() 要点 git push --mirror xxx可以push仓下的所有分支和tag至origin上。 通过python进入不同的工作目录应通过os.chdir(path)而不是os.system(&#39;cd /Users/xxx&#39;).]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm设置和取消代理的方法]]></title>
    <url>%2Fpost%2F8f460f7b.html</url>
    <content type="text"><![CDATA[设置代理12npm config set proxy=http://127.0.0.1:8087npm config set registry=http://registry.npmjs.org 关于https经过上面设置使用了http开头的源，因此不需要设https_proxy了，否则还要增加一句: 1npm config set https-proxy http://server:port 代理用户名和密码12npm config set proxy http://username:password@server:portnpm confit set https-proxy http://username:password@server:port 取消代理12npm config delete proxynpm config delete https-proxy 修改源请参考https://segmentfault.com/a/1190000002589144]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级Node.js至8.0后hexo报错的解决]]></title>
    <url>%2Fpost%2F635ec9a4.html</url>
    <content type="text"><![CDATA[简介本文介绍升级Node.js至8.0后使用hexo新建文章过程中报各种异常的解决方法. 遇到的问题hexo新建文章时报一堆异常: 1234node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 46. This version of Node.js requiresNODE_MODULE_VERSION 57 这个DTraceProviderBindings.node一直报错，跟hexo-fs有关。 此外使用hexo clean --debug时能看到如下: 12345678910111213141516171819202122232425262728293031 hexo git:(master) ✗ hexo clean --debug14:07:03.119 DEBUG Hexo version: 3.3.814:07:03.122 DEBUG Working directory: ~/work/hexo/14:07:03.243 DEBUG Config loaded: ~/work/hexo/_config.yml14:07:03.486 DEBUG Plugin loaded: hexo-abbrlink14:07:03.524 DEBUG Plugin loaded: hexo-util14:07:03.792 DEBUG Plugin loaded: hexo-deployer-git(node:25070) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.14:07:03.846 DEBUG Plugin loaded: hexo-algolia14:07:03.851 DEBUG Plugin loaded: hexo-generator-archive14:07:03.854 DEBUG Plugin loaded: hexo-generator-category14:07:03.858 DEBUG Plugin loaded: hexo-generator-tag14:07:03.862 DEBUG Plugin loaded: hexo-fs14:07:03.867 DEBUG Plugin loaded: hexo-generator-index14:07:03.873 DEBUG Plugin loaded: hexo-renderer-ejs14:07:04.019 DEBUG Plugin loaded: hexo-server14:07:04.020 DEBUG Plugin loaded: hexo-renderer-stylus14:07:04.040 DEBUG Plugin loaded: hexo-renderer-marked14:07:04.043 DEBUG Script loaded: themes/next/scripts/merge-configs.js14:07:04.043 DEBUG Script loaded: themes/next/scripts/tags/button.js14:07:04.078 DEBUG Script loaded: themes/next/scripts/tags/exturl.js14:07:04.079 DEBUG Script loaded: themes/next/scripts/tags/center-quote.js14:07:04.083 DEBUG Script loaded: themes/next/scripts/merge.js14:07:04.083 DEBUG Script loaded: themes/next/scripts/tags/full-image.js14:07:04.084 DEBUG Script loaded: themes/next/scripts/tags/label.js14:07:04.084 DEBUG Script loaded: themes/next/scripts/tags/lazy-image.js14:07:04.085 DEBUG Script loaded: themes/next/scripts/tags/note.js14:07:04.085 DEBUG Script loaded: themes/next/scripts/tags/group-pictures.js14:07:04.086 DEBUG Script loaded: themes/next/scripts/tags/tabs.js14:07:04.088 INFO Deleted database.14:07:04.090 DEBUG Database saved 可以看到hexo-deployer-git这个module用了一个废弃的方法. 问题的原因原因是Node.js从6.0的版本升到8.10.0后，老的module不兼容了，我们只需要升级module就好了。 解决方法参考http://yangbingdong.com/2017/build-blog-hexo-base/并没有解决问题。最终我的解决方法如下: 重装hexo-cli执行命令npm install hexo-cli -g安装最新版本的hexo-cli，版本为1.1.0. 之后使用hexo clean --debug观察出错的module,从https://www.npmjs.com/查到最新版本，然后修改至package.json即可，需要改的有:之后在博客根目录下执行npm update即可。最后通过hexo version可以查到对应版本:1234567891011121314151617➜ hexo git:(master) ✗ hexo versionhexo: 3.3.8hexo-cli: 1.1.0os: Darwin 17.4.0 darwin x64http_parser: 2.7.0node: 8.10.0v8: 6.2.414.50uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2nicu: 60.1unicode: 10.0cldr: 32.0tz: 2017c package.json如下: 12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.3.8&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;gitment&quot;: &quot;0.0.3&quot;, &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-abbrlink&quot;: &quot;^2.0.5&quot;, &quot;hexo-algolia&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-fs&quot;: &quot;^0.2.3&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.2&quot;, &quot;hexo-util&quot;: &quot;^0.6.3&quot; &#125;&#125;]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm安装依赖至指定版本的方法]]></title>
    <url>%2Fpost%2Ff007732d.html</url>
    <content type="text"><![CDATA[简介本文介绍npm安装依赖至指定版本的方法,依赖的版本可以在淘宝镜像或官方查询到. 三种方法方法一先在package.json里修改好指定版本号，然后输入: 1npm update webpack 方法二1npm update webpack@4.7.0 会把webpack更新至指定版本，但是不会写到package.json文件里，如果需要写到package.json里执行如下命令: 1npm update webpack@4.7.0 --save 其中--save等于-S. 方法三1npm update webpack@latest -S --save和--save-dev区别一句话:--save-dev是你开发时依赖的东西，--save是发布后还依赖的东西. 参考 https://segmentfault.com/q/1010000009049039?_ea=1823977 https://segmentfault.com/q/1010000005163089]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RePlugin研究一:基础接入教程]]></title>
    <url>%2Fpost%2F98c4f5c4.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android UI设计换算关系一览表]]></title>
    <url>%2Fpost%2Fc9b0b45c.html</url>
    <content type="text"><![CDATA[本文介绍Android开发和UI设计中不同屏幕尺寸对应的px和dp之间的换算关系。对于Android开发而言，拿到设计师的UI设计图后，根据设计时的屏幕尺寸及标注信息，根据此表能准确得道换算关系，正确的将切图放置到Android工程中的资源文件夹. 对照表 资源文件 ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi 原始密度PPI 120 160 240 320 480 640 density 0.75 1 1.5 2 3 4 屏幕尺寸 480*800 720*1280 1080*1920 2160*3840 备注 HD高清 FHD全高清 UHD全高清 dp 1 1 1 1 1 1 px 0.75 1 1.5 2 3 4 参考链接 常用尺寸 所有可操作元素最小点击区域尺寸48dp*48dp,图表大小则为18*18dp 顶部状态栏高度:24dp AppBar最小高度:56dp 低步导航栏高度:48dp 悬浮按钮尺寸:56dp*56dp / 40*40dp 用户头像:64*64dp / 40*40dp 小图标点击区域:48*48 侧边抽屉到屏幕右边距离:56dp 卡片间距:8dp 分割线上下留白:8dp 大多元素的留白距离:16dp 屏幕左右对齐基线:16dp 文字左侧对齐基线:72dpUI尺寸工具类DisplayUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class DisplayUtil &#123; private static final String TAG = Class.class.getName(); private static int mScreenWidth = -1; private static int mScreenHeight = -1; private static float mDensity = -1; /** * 获取屏幕宽度 * @param context * @return */ public static int getScreenWidth(Context context)&#123; if(mScreenWidth &lt; 0)&#123; init(context); &#125; return mScreenWidth; &#125; /** * 获取屏幕高度 * @param context * @return */ public static int getScreenHeight(Context context)&#123; if(mScreenHeight &lt; 0)&#123; init(context); &#125; return mScreenHeight; &#125; public static float getDensity(Context context)&#123; if(mDensity &lt; 0)&#123; init(context); &#125; return mDensity; &#125; private static void init(Context context)&#123; DisplayMetrics dm =context.getResources().getDisplayMetrics(); mScreenWidth = dm.widthPixels; mScreenHeight = dm.heightPixels; mDensity = dm.density; &#125; /** * dip转px * @param context * @param dipValue * @return */ public static int dip2px(Context context, float dipValue)&#123; if(mDensity &lt; 0)&#123; init(context); &#125; return (int)(dipValue * mDensity + 0.5f); &#125; /** * px转dip * @param context * @param pxValue * @return */ public static int px2dip(Context context, float pxValue)&#123; if(mDensity &lt; 0)&#123; init(context); &#125; return (int)(pxValue / mDensity + 0.5f); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈Mac上Privoxy实现socks5转http(附High Sierra上privoxy启动不了问题的解决)]]></title>
    <url>%2Fpost%2Fc75a2f22.html</url>
    <content type="text"><![CDATA[简介Privoxy是一个可以将socks5道理转成http代理的东西，弥补很多三方软件无法直接走socks5流量的缺点。之前Mac上Privoxy一直都工作的好好的，但是后来不能用了，本文介绍Mac上(High Sierra版本)Privoxy启动不了的问题。 解决方法出现问题后，试了很多种方法，包括卸载重装等，一直都无效，Privoxy根本起不起来。最后迷瞪过来，是因为我把Mac升级到了High Sierra但是Xcode还停留在老版本的原因。所以各位如果你升级了Mac大版本一定要记得升级XCode。下面介绍用Brew安装Privoxy的方法，所有操作都是升级XCode后进行的。 Brew安装Privoxy输入命令:brew install privoxy就ok了。之后修改配置文件/usr/local/etc/privoxy/config,搜索socks5找到下面这一句: 1#forward-socks5t / 127.0.0.1:9050 . 其中9050是Tor浏览器提供的本地socks5端口，这句不用管，直接在下面加一句: 1forward-socks5 / 127.0.0.1:1080 . 这里1080是本地socks5的端口，记住最后面有一个点号不能少.另外还能看到默认的一句: 1listen-address 127.0.0.1:8118 这表示privoxy只兼听本机的8118端口，如果你希望其他局域网内都可以用这个代理可以修改为: 1listen-address 0.0.0.0:8118 开机自启之前从来没有设置过开机自启，都是需要用到时才用脚本去启动，现在来看太麻烦了。完全可以让他开机启动，用到时去接到8118端口就可以了。用brew安装完毕后，会看到下面一段话: 123456789==&gt; Installing privoxy==&gt; Downloading https://homebrew.bintray.com/bottles/privoxy-3.0.26.high_sierra.######################################################################## 100.0%==&gt; Pouring privoxy-3.0.26.high_sierra.bottle.1.tar.gz==&gt; CaveatsTo have launchd start privoxy now and restart at login: brew services start privoxyOr, if you don&apos;t want/need a background service you can just run: privoxy /usr/local/etc/privoxy/config 如果想设置开机启动的话，只需要:sudo brew services start privoxy就ok了。如果单次启动的话用/usr/local/sbin/privoxy /usr/local/etc/privoxy/config。备注:这个启动方式和用Privxoy原始安装方式还是有区别的。 验证是否启动方式一经过上述操作打开shadowsocks和privoxy后，就需要验证socks5代理转http是否成功。首先看privoxy是否启动起来了,输入ps -ef|grep privoxy可以看到: 123501 400 1 0 4:58下午 ?? 0:00.18 /usr/local/Cellar/privoxy/3.0.26/sbin/privoxy --no-daemon /usr/local/etc/privoxy/config501 402 1 0 4:58下午 ?? 0:00.01 /Users/yanzi/Library/Application Support/ShadowsocksX-NG/privoxy --no-daemon privoxy.config501 1625 1600 0 6:46下午 ttys001 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn privoxy 可以看到已经启动成功了。 方式二输入netstat -an | grep 8118可以看到: 1tcp4 0 0 127.0.0.1.8118 *.* LISTEN 也能证明已经ok了。 方式三最根本的方法莫过于通过8118端口访问google了: 12wget -e http_proxy=127.0.0.1:8118 www.google.comcurl -x 127.0.0.1:8118 www.google.com 用wget和curl都是ok的。 终端也能用代理在~/.zshrc里加上两句: 12export http_proxy=&apos;http://127.0.0.1:8118&apos;export https_proxy=&apos;http://127.0.0.1:8118&apos; 通过echo $http_proxy要确保其生效,此时在console里wget Google的话就不需要指定代理也能出去了。 参考 https://segmentfault.com/a/1190000008848001 官方quickstart]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo algolia文章过长报错的解决方法]]></title>
    <url>%2Fpost%2F4a3fe015.html</url>
    <content type="text"><![CDATA[简介本文介绍当文章过长，执行hexo algolia时报错AlgoliaSearchError: Record at the position ... is too big size的解决方法. 解决方法找到command.js这个文件，将var storedPost =这一句做以下替换: 12// var storedPost = _.pick(data, [&apos;title&apos;, &apos;date&apos;, &apos;slug&apos;, &apos;path&apos;, &apos;content&apos;, &apos;excerpt&apos;, &apos;objectID&apos;]); var storedPost = _.pick(data, [&apos;title&apos;, &apos;date&apos;, &apos;slug&apos;, &apos;path&apos;, &apos;objectID&apos;]); 上面注释掉的就是原来的，虽然这种方法有弊端，不过其他的也没找到啥好方法。]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux实现定时重启]]></title>
    <url>%2Fpost%2F1b7970e0.html</url>
    <content type="text"><![CDATA[简介本文介绍在CentOS和Debian上实现定时重启的功能. 检查crond服务是否开机自启CentOS上运行systemctl is-enabled crond.service，如果是disabled的话运行systemctl enable crond.service开启。 注意:如果crond服务不能开机自启的话，则第一次重启后，以后定时任务就没法持续了。 开启crond服务运行:service start crond开启服务，service crond status查看状态： 1Active: active (running) since Sun 2017-09-24 09:26:23 EDT; 3h 32min ago 包含以上输出表示已经开启crond服务. 创建定时任务创建:crontable -e,之后输入: 10 4 * * * /sbin/reboot 表示每天早上4:0分重启.]]></content>
      <categories>
        <category>综合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenCV修改ROI区域值时需注意数据类型]]></title>
    <url>%2Fpost%2F935cfe01.html</url>
    <content type="text"><![CDATA[简介本文介绍使用OpenCV在修改矩阵特定区域也就是ROI值的时候，需要注意的事项。如果类型错误，将得到错误的结果. 正式交代主题前，先看以下几个点. imread函数我们主要是关注第二个参数,有以下四种: 1234CV_LOAD_IMAGE_ANYDEPTH - If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.CV_LOAD_IMAGE_COLOR - If set, always convert image to the color oneCV_LOAD_IMAGE_GRAYSCALE - If set, always convert image to the grayscale one&gt;0 Return a 3-channel color image. 默认下传的是CV_LOAD_IMAGE_COLOR,得到的Mat type为CV_8UC3,如果传的是CV_LOAD_IMAGE_GRAYSCALE则表示加载的是灰度图像，type为CV_8UC1。 设置ROI方式有大概有2种: 拷贝构造函数 1Mat roi = Mat(gray, Rect(100, 0, 30, 30)); 当然上面也完全等价于下面这句: 1Mat roi(gray, Rect(100, 0, 30, 30)); 可能是写Java多的原因，我更喜欢前面的那种写法.2. 使用操作符 1Mat srcROI = src(Rect(0,0,src.cols/2,src.rows/2)); Rect的使用最常见的一种构造方法是: 1Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height); 其中x表示ROI区域的x坐标(横轴为X),也就是第几列的意思，y就不解释了。width表示ROI区域的宽度. Mat元素访问链接列举了13种访问方法，这里又精简到3种，如果对效率没什么太高要求那么还是第一种用起来比较顺手: 1234567for (int i=0; i&lt;ROWS ; i++) &#123; for (int j=0; j&lt;COLS ; j++) &#123; img1.at&lt;float&gt;(i,j) = 3.2f; &#125; &#125; 这里的Mat.at(i, j),其中i表示第几行，j表示第几列. 修改特定区域的值目的就是要将roi区域灰度值置为0: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;#include &lt;opencv2/opencv.hpp&gt;using namespace cv;using namespace std;void clearMat(Mat a)&#123; if(a.empty())&#123; return; &#125; for(int i = 0; i&lt;a.rows; i++) for(int j = 0; j&lt;a.cols; j++)&#123; a.at&lt;uchar&gt;(i, j) = 0; &#125;&#125;int main(int argc, const char * argv[]) &#123; // insert code here... cout &lt;&lt; &quot;Hello, World!\n&quot;; string path = &quot;/Users/yanzi/Pictures/lena.jpg&quot;; Mat img = imread(path); //显示灰度图 Mat gray; cvtColor(img, gray, COLOR_RGBA2GRAY); Mat gray1 = imread(path, IMREAD_GRAYSCALE); // Mat roi = Mat(gray, Rect(100, 0, 30, 30)); Mat roi(gray, Rect(100, 0, 30, 30)); clearMat(roi); namedWindow(&quot;gray&quot;); imshow(&quot;gray&quot;, gray); waitKey(0); return 0;&#125; 我们将gray矩阵的那个rect区域弄成黑色，效果图如下:可以看到运行的丝毫不差。注意我们在访问矩阵元素是是将其设为uchar,如果将其改为int看一下效果:起点是对的，但是宽度变成了需求的四倍。这是因为uchar只占一个字节，而int为4个字节.当错误的将其转为int后，就会发生实际修改的区域越位的情况。所以当修改Mat时一定格外注意. 下面是深度和取值范围的对应关系: 1234567CV_8U - 8-bit unsigned integers ( 0..255 )CV_8S - 8-bit signed integers ( -128..127 )CV_16U - 16-bit unsigned integers ( 0..65535 )CV_16S - 16-bit signed integers ( -32768..32767 )CV_32S - 32-bit signed integers ( -2147483648..2147483647 )CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN ) 我们还要清楚这个depth和数据类型的对应关系: 1234567Mat_&lt;uchar&gt;---------CV_8UMat&lt;char&gt;-----------CV_8SNat_&lt;short&gt;---------CV_16SMat_&lt;ushort&gt;--------CV_16UMat_&lt;int&gt;-----------CV_32SMat_&lt;float&gt;----------CV_32FMat_&lt;double&gt;--------CV_64F 这样就不会出错了。再贴一段如果是三通道时的访问方法: 12345678910111213int ROWS = 100; // height 2 int COLS = 200; // width 3 Mat img1(ROWS , COLS , CV_8UC3); 4 5 for (int i=0; i&lt;ROWS ; i++) 6 &#123; 7 for (int j=0; j&lt;COLS ; j++) 8 &#123; 9 img1.at&lt;vec3b&gt;(i,j)[0]= 3.2f; // B 通道10 img1.at&lt;vec3b&gt;(i,j)[1]= 3.2f; // G 通道11 img1.at&lt;vec3b&gt;(i,j)[2]= 3.2f; // R 通道12 &#125; 13 &#125; 参考 http://www.cnblogs.com/dupuleng/articles/4072736.html opencv2.4.13官方文档]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab里double和uint8对imshow函数的影响]]></title>
    <url>%2Fpost%2Fa525c216.html</url>
    <content type="text"><![CDATA[背景本文介绍double和uint8两种数据类型对imshow函数造成的影响，如果使用不当用imshow函数显示double类型数据时将得到二值化黑白图像的效果。 double和uint8差异在matlab里imread之后默认是unit8类型的矩阵，即范围为0-255.但是很多图像变化中是需要数据类型为double的，这就需要将unit8通过double()转换即可，经过转换后数字没变，即原来是200则会变成200.0，仅仅是类型发生变化。但是对imshow函数而言，如果数据是double，它会认为图像正常区间是0-1,即0是黑，1是白,而超过1的都会认为是上限值1，即白色. 下面上一个代码: 123456789101112clc;path = &apos;/Users/yanzi/Pictures/lena.jpg&apos;;image = imread(path);gray = rgb2gray(image);figure, imshow(gray), title(&apos;gray&apos;);gray2 = double(gray);gray2(1:10, 1:10)=0;figure, imshow(gray2), title(&apos;gray2&apos;);gray3 = im2double(gray);figure, imshow(gray3), title(&apos;gray3&apos;); 其中gray是原图像，gray2是用double转换的，转换后可以看到它的数值没发生变化:上面的10*10是为了故意看到效果，设成了0，显示图像如下:最左边是原始灰度图像，中间是转double之后的，可以看到除了设0的那部分是黑之外，其他全是白的。 im2double注意到上图最右边的图像，显示也是正常的，它的数值范围是:可以看到im2double能将0-255范围内的unit8数据转成double类型的0-1范围内的数据，且能显示正常. 互相转换 假设原始矩阵为uint8矩阵，如果你通过double()转成了double,那么你转回来只需通过uint8()即可。 如果你通过im2double转成了0-1区间的double，想转回去的话通过im2uint8()就能得到0-255范围的uint8数据. 参考 http://blog.csdn.net/fx677588/article/details/53301740]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题去掉码市的Coding Pages等待页]]></title>
    <url>%2Fpost%2F2dde9ec2.html</url>
    <content type="text"><![CDATA[简介本文介绍去除码市的Coding Pages的等待跳转页的方法,采用hexo的next主题5.1.2版本. 1.升级银牌会员完善信息就ok，这一步是必须的。 2.修改footer.swig找到主题下的这个文件，找到这一行: 1&lt;div class=&quot;theme-info&quot;&gt; 原来这里面放的是主题 — NexT.Pisces v5.1.2，如下图所示:其实这个没什么卵用，将这个div的东西都删掉，然后添加一句: 1&lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt; 最后完整的尾部信息是: 1234567891011&#123;% if theme.copyright %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;div class=&quot;theme-info&quot;&gt; &lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt; &lt;/div&gt;&#123;% endif %&#125; 最终的效果:既保证了原来的结构也达到了效果。之前曾尝试过在copyright也就是博主名后面加(参考链接1的方案)弄两个竖线，但是又对不齐无奈太丑了所以放弃. 参考 http://blog.csdn.net/yingpaixiaochuan/article/details/77113397 http://zhanghao.studio/%E6%8F%90%E5%8D%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6.html]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题集成gitment评论系统]]></title>
    <url>%2Fpost%2Fab9bb85a.html</url>
    <content type="text"><![CDATA[简介本文介绍hexo next主题(5.1.2)集成giment评论系统的过程。所谓gitment就是把评论放到github的issues系统里，评论支持md，比较适合程序员. 一.注册OAuth Application点击https://github.com/settings/applications/new注册，注意Authorization callback URL填自己的网站urlhttp://yangq.me/.记下Client ID和Client Secret. 二.修改themes/next/_config.yml在其中添加: 123456789# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true githubID: yourid repo: yourrepo ClientID: yourid ClientSecret: yoursecret lazy: true 注意:格式要正确，该空格的一定要空格。所有的yourXXX都换成自己的. 在主题的en.yml增加: 1gitmentbutton: Show comments from Gitment zh-Hans.yml增加: 1gitmentbutton: 显示 Gitment 评论 三.修改主题layout/_partials/comments.swig找到这个文件里的这两行: 12&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; 上面是最后一个elseif分支，在下面加一个elseif分支: 12345678&#123;% elseif theme.gitment.enable %&#125; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick=&quot;ShowGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt; &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; 加完之后下面的内容是原来的，保持不变: 123 &#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 四.增加gitment.swig在主题下layout/_third-party/comments/目录下中添加文件gitment.swig： 12345678910111213141516171819202122232425262728293031323334353637&#123;% if theme.gitment.enable %&#125; &#123;% set owner = theme.gitment.githubID %&#125; &#123;% set repo = theme.gitment.repo %&#125; &#123;% set cid = theme.gitment.ClientID %&#125; &#123;% set cs = theme.gitment.ClientSecret %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; &#123;% if not theme.gitment.lazy %&#125; &lt;script type=&quot;text/javascript&quot;&gt; var gitment = new Gitment(&#123; id: window.location.pathname, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &lt;/script&gt; &#123;% else %&#125; &lt;script type=&quot;text/javascript&quot;&gt; function ShowGitment()&#123; document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;; document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;; var gitment = new Gitment(&#123; id: document.location.href, owner: &apos;&#123;&#123;owner&#125;&#125;&apos;, repo: &apos;&#123;&#123;repo&#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123;cid&#125;&#125;&apos;, client_secret: &apos;&#123;&#123;cs&#125;&#125;&apos;, &#125;&#125;); gitment.render(&apos;gitment-container&apos;); &#125; &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在主题下layout/_third-party/comments/index.swig文件中引入gitment.swig文件： 1&#123;% include &apos;gitment.swig&apos; %&#125; 五.添加gitment.styl在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件，设置button的样式： 12345678910111213#gitment-display-button&#123; display: inline-block; padding: 0 15px; color: #0a9caf; cursor: pointer; font-size: 14px; border: 1px solid #0a9caf; border-radius: 4px; &#125; #gitment-display-button:hover&#123; color: #fff; background: #0a9caf; &#125; 然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可: 1@import &quot;gitment&quot;; 这样就ok了！ 易错点 修改themes/next/_config.yml这个文件时，格式要正确。另外，repo是你要想创建issues的仓库，完全可以跟博文所放的仓库不一个。id就写自己的github用户名就可以，这个用户名跟repo必须匹配。 gitment可能不支持链接地址里有中文，所以安装gitment前一定要参考前文把链接持久化搞成全是英文的。 同一篇文章需要初始化comment两次的问题，是因为http://xxx.com/post/ab9bb85a.html和点击阅读全文进去的链接http://xxx.com/post/ab9bb85a.html#more对issues来说是不同的，所以创建两次。解决方法就是gitment.swig里id弄成window.location.pathname而不是document.location.href。 初始化评论后，可以到github里自己放issues的仓库查看issues是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。 参考文档 主要参考文档 一种相对简略的配置方式 作者issue]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo链接持久化终极解决之道]]></title>
    <url>%2Fpost%2F19acb239.html</url>
    <content type="text"><![CDATA[背景大家知道hexo默认的链接是http://xxx.yy.com/2013/07/14/hello-world这种类型的，这源于站点目录下的配置_config.yml里的配置:permalink: :year/:month/:day/:title/.这种默认配置的缺点就是一般文件名是中文，导致url链接里有中文出现，这会造成很多问题，如使用gitment，也不利于seo。另外就是年月日都会有分隔符。本文介绍经过作者研究总结出的最终解决方案。 过时解决方案在md文件的Front-matter区域，增加一个urlname属性，用来放文章的英文名字。如下图所示: 12345678title: hexo链接持久化终极解决之道urlname: hexo_permalinkdate: 2017-08-31 23:53:24comments: truecategories:- 综合tags:- hexo 然后修改_config.yml里的配置: 123permalink: posts/:category/:year:month:day-:urlname.htmlpermalink_defaults: urlname: index 后缀增加.html给人以静态页面感觉，利于seo.这里面:urlname表示引用的这个变量。前面是分类／年月日。另外增加一个urlname这个属性的默认值，当md文档里不填这个属性，就用这个值。这里设的是index,也就是说如果不填这个属性,其链接为:http://xxx.com/posts/uncategorized/20170828-index.html。当然最好写上这个属性，偶尔某天不写这个属性也没关系。 另外还要解决一个问题，就是:category分类有可能为中文。为此在站点下配置文件里设置: 123default_category: uncategorizedcategory_map: 综合: common 这样在Front-matter里，分类该写中文写中文，最终的链接会翻译成英文。 终极方案无意中看到http://muyunyun.cn/posts/f55182c5/#more,最终决定采用这种方案使用hexo-abbrlink这个插件，猜测是根据时间点算出的最终链接,后期不管怎么修改永久链接都不会变.一来自己不用再增加什么属性了，也不用考虑分类中文化的问题。二来后面的层级更短，更利于SEO。(一般SEO只爬三层) 1npm install hexo-abbrlink --save 站点配置文件里: 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 另外可以修改scaffolds里的模版文件，修改post.md为: 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;comments: truecategories:tags:--- 不建议的写法 有的人采用了md文件的名字是英文，在Front-matter里将title写成正常的中文呢，这个将来文章多了，都是英文不利于收藏整理。 参考链接 https://hexo.io/zh-cn/docs/permalinks.html https://yq.aliyun.com/articles/8607 http://muyunyun.cn/posts/f55182c5/#more http://blog.csdn.net/mrDiordna/article/details/66472673]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vultr Debian7上搭建科学上网，使用锐速畅享十倍提速]]></title>
    <url>%2Fpost%2F170b145.html</url>
    <content type="text"><![CDATA[背景之前博文里有介绍过搭建科学上网环境后，使用锐速进行提速，但是加速的效果有时候觉得好，有时候觉得不行。最近帮朋友在vultr上申请一个IP，搭建环境后，发现同WIFI环境下新IP下载速度只有20-30KB，老IP能达到1M左右。在另一处wifi环境下，GooglePlay上下载应用老IP速度达2M左右，新IP只有400多kb。本来想给vultr提个ticket反馈下这个情况，最后想起来老IP上装了锐速，待新IP装上锐速后youtube速度竟飙到14M，有感与此详细记录此次折腾过程。服务器选择的是debian7 64位，所占内存很小，也不需要改防火墙端口，装锐速时也不需要换内核，比较方便。 安装shadowsocks参考博文，运行如下命令安装: 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完毕后使用service shadowsocks status查看服务运行状态，执行service shadowsocks restart|stop|start对应重启、停止、启动该服务。 创建多用户shadowsocks配置这里交代一点，vultr的debian7上不需要像CentOS上修改防火墙端口.多用户配置为: 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 为了批量创建端口号和对应的密码，我写了个python脚本，根据端口作出计算其对应的密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 2017/8/21 下午10:56# @Author : yanzi1225627# @Site : # @File : main.py# @Software: PyCharm Community Editionimport _md5import hashlibimport jsondef getMd5(src): m1 = hashlib.md5() m1.update(str.encode(src)) return m1.hexdigest()def getPswdByPort(port): data = port / 37 + 555 data1 = str(data) + &apos;shadowsocks&apos; md = getMd5(data1) return md[:6]def main(): pswds = &#123;&#125; for p in range(7000, 7020): pswd = getPswdByPort(p) # print(&quot;%s : %s&quot; % (str(p), pswd)) pswds.setdefault(str(p), pswd) print(pswds) config = &#123; &quot;server&quot;:&quot;your ip&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:pswds, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;:False &#125; jsObj = json.dumps(config) file= open(&apos;./config.json&apos;, &apos;w&apos;) file.write(jsObj) file.close()if __name__ == &apos;__main__&apos;: main() 安装锐速其加速的核心是zeta-tcp,国外人最先提出来的，一种典型的单边加速，只需要在服务器部署即可。首先执行uname -a查看内核如下: 1Linux guest 3.2.0-4-amd64 #1 SMP Debian 3.2.89-2 x86_64 GNU/Linux 可以看到其内核是debian的3.2.0-4-amd64，查看锐速支持的内核列表如下,可以看到在支持范围:所以就不用更换内核了。运行如下脚本安装: 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 卸载脚本: 1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 安装完毕后，你需要知道几个命令: 几个相关命令:service serverSpeeder status 查看serverSpeeder的状态 service serverSpeeder start | stop | restart 停止暂停重启锐速安装目录就在/serverspeeder,其配置文件路径:/serverspeeder/etc/config,基本按照默认配置就ok。 在youtube上搜索1080p 测试视频,如https://www.youtube.com/watch?v=Bey4XXJAqS8可以看到加速后速度飙到了40M左右，右边的TotalActiveTcpFlow这个数字用来检验锐速是否生效，越大越好。关闭锐速后，其速度在3-4M左右，如下图: 总结文中用到的所有脚本已备份至github,如果文中的链接或脚本被墙了，请到github里查看。如果本文对你有帮助且需要vultr的话，请点此我的推广注册，我得优惠您得实惠～～～]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用启动流程分析]]></title>
    <url>%2Fpost%2Fc1c83cc.html</url>
    <content type="text"><![CDATA[ActivityThread是Activity里一个很重要的成员变量，俗称UI线程，也即应用的主线程,它自身有三个比较关键的成员变量，其中之一是ApplicationThread,在ActivityThread创建的时候作为全局变量被创建: 1234final ApplicationThread mAppThread = new ApplicationThread();final ApplicationThread mAppThread = new ApplicationThread();final Looper mLooper = Looper.myLooper();final H mH = new H(); ApplicationThread是ActivityThread里一个内部类，继承自ApplicationThreadNative,而ApplicationThreadNative又继承自Binder并implements了IApplicationThread接口(此处并没有真正实现)，IApplicationThread继承IInterface,定义了一系列操作应用的接口，用来和AMS进行通信,其中和Activity生命周期相关的几个关键函数如下: 12345void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving,int configChanges, boolean dontReport) throws RemoteException;void scheduleStopActivity(IBinder token, boolean showWindow,int configChanges) throws RemoteException;void scheduleResumeActivity(IBinder token, int procState, boolean isForward, Bundle resumeArgs)throws RemoteException; IInterface.java代码如下: 123456789public interface IInterface&#123; /** * Retrieve the Binder object associated with this interface. * You must use this instead of a plain cast, so that proxy objects * can return the correct result. */ public IBinder asBinder();&#125; Binder.java实现了IBinder接口，核心的onTransact函数和transact代码如下: 12345678910111213141516protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; if (code == INTERFACE_TRANSACTION) &#123; reply.writeString(getInterfaceDescriptor()); return true; &#125; else if (code == DUMP_TRANSACTION) &#123; ParcelFileDescriptor fd = data.readFileDescriptor(); String[] args = data.readStringArray(); if (fd != null) &#123; try &#123; dump(fd.getFileDescriptor(), args); &#125; finally &#123; IoUtils.closeQuietly(fd); &#125; &#125; ........ 12345678910111213public final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this); if (data != null) &#123; data.setDataPosition(0); &#125; boolean r = onTransact(code, data, reply, flags); if (reply != null) &#123; reply.setDataPosition(0); &#125; return r; &#125; 注意上面的transact()函数是final修饰，不可被子类重写，但onTransact()可以被重写。ApplicationThreadNative的主要功能就是重写了onTransact函数，根据不同的code路由给内部类ApplicationThreadProxy(实现了IApplicationThread接口),完成和binder通讯的部分.也即真正实现IApplicationThread接口的有两个类：ApplicationThread和ApplicationThreadProxy,其中ApplicationThread负责通过ActivityThread最终控制Activity的生命周期，ApplicationThreadProxy负责对应功能与Binder通讯的部门。也可以说ApplicationThread具有上面两部分功能，只不过按层次实现在不同类里. 以schedulePauseActivity()接口为例，ApplicationThreadProxy实现为: 12345678910111213public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); data.writeStrongBinder(token); data.writeInt(finished ? 1 : 0); data.writeInt(userLeaving ? 1 :0); data.writeInt(configChanges); data.writeInt(dontReport ? 1 : 0); mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; ApplicationThread对其实现为: 123456789101112public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123; int seq = getLifecycleSeq(); if (DEBUG_ORDER) Slog.d(TAG, &quot;pauseActivity &quot; + ActivityThread.this + &quot; operation received seq: &quot; + seq); sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0), configChanges, seq);&#125; 其中sendMessage实现为: 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; mH继承自Handler负责处理ApplicationThread发送到消息队列的消息，例如： 12345678910111213public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ......... 上面把ActivityThread、ApplicationThread、ApplicationThreadProxy、ApplicationThreadNative的关系说清楚了，下面接着看流程. step3–Instrumentation.execStartActivityInstrumentation里的execStartActivity()核心代码如下: 1234567891011121314151617181920public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; ......... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null;&#125; 最关键的是int result = ActivityManagerNative.getDefault().startActivity(...),ActivityManagerNative在路径:/frameworks/base/core/java/android/app/ActivityManagerNative.java,其中的getDefault()函数返回内部的变量:gDefault: 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); &#125; return am; &#125;&#125; ServiceManager路径/frameworks/base/core/java/android/os/ServiceManager.java,它就是Android的ServiceManager进程，本身也是一个服务，内部通过一个HashMap类型sCache变量保存各种Service的Binder接口,如下: 1234567891011121314151617181920private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;();public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; ......... &#125;public static void addService(String name, IBinder service) &#123; try &#123; getIServiceManager().addService(name, service, false); &#125; catch (RemoteException e) &#123; Log.e(TAG, &quot;error in addService&quot;, e); &#125; &#125; 从中可以看到gDefault实质是ActivityManagerService的远程接口,然后通过asInterface这个函数将一个Binder对象转为IActivityManager接口，并生成了一个ActivityManagerProxy对象： 12345678910111213141516/** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */ static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj); &#125; 所以最终又调到了ActivityManagerProxy.startActivity函数.这里ActivityManagerNative和ActivityManagerProxy,与ApplicationThreadNative和ApplicationThreadProxy在实现模式上是一样的。 step4–ActivityManagerProxy.startActivity123456789101112131415161718192021222324class ActivityManagerProxy implements IActivityManager&#123; public ActivityManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); ......data.writeString(callingPackage); intent.writeToParcel(data, 0); ... mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; 上面说过在ActivityManagerProxy被创建的时候传进来一个IBinder对象，这个就是AMS的远程调用接口，也即mRemote变量.这里最核心的一句是:mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0)。 step4–ActivityManagerService.startActivity上个步骤里的mRemote.transact()就是利用binder驱动进行跨进程通信的过程，在mRemote的onTransact函数里一定有个地方去响应START_ACTIVITY_TRANSACTION这个命令。 注意:上面的步骤都是在初始应用程序A进程里，在onTransact时来到了AMS，也即AMS所在的SystemServer进程. 我们直接到ActivityManagerService里去找.源码在/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java,它继承了上面的ActivityManagerNative,在其onTransact函数里找到: 123456789101112131415public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); ............. int result = startActivity(........); reply.writeNoException(); reply.writeInt(result); return true; &#125; 这里又调用了startActivity函数，但是ActivityManagerNative是个abstract类，并没有真正实现IActivityManager接口，其实现在其子类ActivityManagerService里。它又调了内部的startActivityAsUser()函数,最终又进到mActivityStarter.startActivityMayWait()函数里。 step5–ActivityStarter.startActivityMayWait备注:此处往下的流程集中在ActivityStackSupervisor、ActivityStack、ActivityStarter比较复杂，只交代调用流程，不作太多解释.startActivityMayWait()这个函数比较长，最终又调了内部的startActivityLocked里。doPendingActivityLaunchesLocked—startActivityUnchecked,在startActivityUnchecked通过mSupervisor.resumeFocusedStackTopActivityLocked(),进到ActivityStackSupervisor,然后进到ActivityStack.resumeTopActivityUncheckedLocked,再调内部的resumeTopActivityInnerLocked()函数，再调内部的startPausingLocked函数,其中关键一句: 12prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); 这里prev类型为ActivityRecord,app类型为ProcessRecord,thread类型为IApplicationThread,即prev.app.thread是运行在ActivityManagerService进程里的``ApplicationThread的远程调用接口ApplicationThreadProxy`. step6–ApplicationThreadProxy.schedulePauseActivity代码如下: 123456789 boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); .......... data.writeInt(dontReport ? 1 : 0); mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; 通过进程间通信，来到ApplicationThreadNative里的onTransact函数: 1234567891011public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); IBinder b = data.readStrongBinder(); ...... schedulePauseActivity(b, finished, userLeaving, configChanges, dontReport); return true; &#125; step7–ApplicationThread.schedulePauseActivity注意:经过上面步骤里的onTransact来到了Launcher进程里.schedulePauseActivity()通过ActivityThread里的HandlermH,将消息转发至UI线程里。 123456789case PAUSE_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); SomeArgs args = (SomeArgs) msg.obj; handlePauseActivity((IBinder) args.arg1, false, (args.argi1 &amp; USER_LEAVING) != 0, args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 进到了handlePauseActivity(): 123456789101112131415161718private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; performPauseActivity(token, finished, r.isPreHoneycomb(), &quot;handlePauseActivity&quot;); // Tell the activity manager we have paused. if (!dontReport) &#123; try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true; &#125; &#125; 函数首先将Binder引用token转换成ActivityRecord的远程接口ActivityClientRecord，然后做了三个事情： 如果userLeaving为true，则通过调用performUserLeavingActivity函数来调用Activity.onUserLeaveHint通知Activity，用户要离开它了； 调用performPauseActivity函数来调用Activity.onPause函数，我们知道，在Activity的生命周期中，当它要让位于其它的Activity时，系统就会调用它的onPause函数； 它通知ActivityManagerService，这个Activity已经进入Paused状态了，ActivityManagerService现在可以完成未竟的事情，即启动MainActivity了。ActivityManagerProxy里activityPaused函数如下:1234567891011public void activityPaused(IBinder token) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(token); mRemote.transact(ACTIVITY_PAUSED_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle(); &#125; step8–ActivityManagerService.activityPaused备注:又来到了AMS所在的进程！！！上面的步骤经过进程间通信来到ActivityManagerNative里的： 1234567case ACTIVITY_PAUSED_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder token = data.readStrongBinder(); activityPaused(token); reply.writeNoException(); return true; &#125; 调到AMS的activityPaused()函数。 12345678910public final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized(this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; stack.activityPausedLocked(token, false); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125; step9–ActivityStack.activityPausedLocked12345678910111213final void activityPausedLocked(IBinder token, boolean timeout) &#123; if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Activity paused: token=&quot; + token + &quot;, timeout=&quot; + timeout); final ActivityRecord r = isInStackLocked(token); if (r != null) &#123; mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r); if (mPausingActivity == r) &#123; if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;)); completePauseLocked(true, null); return; &#125; 调到了内部函数completePauseLocked()： 1234567891011completePauseLocked()&#123;....... if (resumeNext) &#123; final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDownLocked()) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null); &#125; &#125; &#125; ......&#125; 最终调了ActivityStackSupervisor里的resumeFocusedStackTopActivityLocked函数. step10–ActivityStackSupervisor.resumeFocusedStackTopActivityLocked通过之前流程可以知道，当前在堆栈顶端的Activity为我们即将要启动的Activity,而Launcher对应的Activity已经被paused了。 1234567891011boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false; &#125; 然后调用ActivityStack的resumeTopActivityUncheckedLocked()函数. step10–ActivityStack.resumeTopActivityUncheckedLocked在resumeTopActivityUncheckedLocked函数里调了自身的resumeTopActivityInnerLocked,然后调自身的resumeTopActivityInnerLocked,最终调了mStackSupervisor.startSpecificActivityLocked(next, true, true). step11–ActivityStackSupervisor.startSpecificActivityLocked12mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); 调到了ActivityManagerService里. step12–ActivityManagerService.startProcessLocked此函数里核心代码如下: 123456checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); step13–Process.start()最终来到了Process(./frameworks/base/core/java/android/os/Process.java),调用自身startViaZygote(),在这个函数里最后一句是: 1return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); 首先通过openZygoteSocketIfNeeded,建AMS进程和Zygote进程通过socket进行跨进程通信的连接.然后zygoteSendArgsAndGetResult()这个函数向zygote进程发送一个参数列表，zygote进程会启动一个新的子进程并返回该子进程的pid号。请求的参数中有一个字符串，它的值是“android.app.ActivityThread”。现在该回到zygote处理请求那块去看看了——就是runSelectLoop函数，具体在ZygoteInit里： 1234567891011121314151617181920212223242526272829303132private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;......... while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(&quot;poll failed&quot;, ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); &#125; &#125; &#125; &#125; &#125; 可以看到里面是一个while循环，一直在监听socket发来的信息，最终调用了ZygoteConnection里的runOnce函数。 12345678910111213141516171819 boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); &#125;.......if (pid == 0) &#123; // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; 这里最终调到了Zygote的两个关键函数forkAndSpecialize函数，然后通过JNI调用了nativeForkAndSpecialize函数,这个函数最终fork了一个子进程,暂时忽略.另外一个函数是handleChildProc()： 123456789if (parsedArgs.invokeWith != null) &#123; WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.remainingArgs); &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125; 这里会走到RuntimeInit.zygoteInit,然后调内部的applicationInit()函数,再调内部的invokeStaticMain()函数: 1234567891011121314151617 private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; ...... Method m; try &#123; m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( &quot;Missing static main on &quot; + className, ex); &#125; ...... &#125; 可以看到，上述代码完成了一个反射的功能，去加载传进来的类名的main方法。在打开应用过程中，这个类名就是android.app.ActivityThread step14–ActivityThread.main()123456789101112131415public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); ...... Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ..... 在main函数里，创建了ActivityThread和主Ui线程Handler,然后调用它的attach函数: 123456final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; 这里mgr就是ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数. 1234567891011public void attachApplication(IApplicationThread app) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app.asBinder()); mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0); reply.readException(); data.recycle(); reply.recycle(); &#125; 这里传进来的参数就是刚刚创建进程的远程调用接口,将其传给AMS。通过跨进程通讯，来到了ActivityManagerService的attachApplication函数。 step15–ActivityManagerService.attachApplication()12345678910if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; &#125; &#125; 这里进到了attachApplicationLocked函数. step16–ActivityStackSupervisor.attachApplicationLocked()12345678ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; ..... 这里先调ActivityStack的topRunningActivityLocked，然后再调自己的realStartActivityLocked: 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 这里app.thread最终进到了ApplicationThreadProxy的scheduleLaunchActivity函数中。 step17–ApplicationThreadProxy.scheduleLaunchActivity()12mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); AMS通过Binder通信，告诉SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION，进到了scheduleLaunchActivity step18–ApplicationThreadProxy.scheduleLaunchActivity()123public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident...) sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 来到了Handler(H)的handleMessage函数里： 123456789case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 调用自己的handleLaunchActivity: 123456789 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;...... Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; ..... handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); .... performPauseActivityIfNeeded(r, reason); 在handleLaunchActivity函数里主要干了两个重要事情,第一是通过performLaunchActivity去加载一个Activity,然后调用它的onCreate方法: 123456789101112131415161718192021222324252627282930private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;......... if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); &#125; ..... try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation);.... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); .... activity.attach(appContext, this, getInstrumentation(), r) .... if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; 在performLaunchActivity函数里，先通过类加载器创建一个Activity对象，然后创建Application对象,调用Activity的attach(),再通过mInstrumentation.callActivityOnCreate调Activity的onCreate。然后回到handleLaunchActivity函数，执行handleResumeActivity,即调Activity的onResume()生命周期。终于，新打开的Activity启动起来了!!! 过程总结整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段： Launcher通过Binder进程间通信机制通知AMS，它要启动一个Activity； AMS通过Binder进程间通信机制通知Launcher进入Paused状态； Launcher通过Binder进程间通信机制通知AMS它已经准备就绪进入Paused状态，于是AMS就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行； ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给AMS，以便以后AMS能够通过这个Binder对象和它进行通信； AMS通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。 调用流程图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
