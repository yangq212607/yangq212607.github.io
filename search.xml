<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android UI设计换算关系一览表</title>
    <url>/post/c9b0b45c.html</url>
    <content><![CDATA[<p>本文介绍Android开发和UI设计中不同屏幕尺寸对应的px和dp之间的换算关系。对于Android开发而言，拿到设计师的UI设计图后，根据设计时的屏幕尺寸及标注信息，根据此表能准确得道换算关系，正确的将切图放置到Android工程中的资源文件夹.</p>
<span id="more"></span>
<h2 id="对照表"><a href="#对照表" class="headerlink" title="对照表"></a>对照表</h2><table>
<thead>
<tr>
<th>资源文件</th>
<th align="center">ldpi</th>
<th align="center">mdpi</th>
<th align="center">hdpi</th>
<th align="center">xhdpi</th>
<th align="center">xxhdpi</th>
<th align="center">xxxhdpi</th>
</tr>
</thead>
<tbody><tr>
<td>原始密度PPI</td>
<td align="center">120</td>
<td align="center">160</td>
<td align="center">240</td>
<td align="center">320</td>
<td align="center">480</td>
<td align="center">640</td>
</tr>
<tr>
<td>density</td>
<td align="center">0.75</td>
<td align="center">1</td>
<td align="center">1.5</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td>屏幕尺寸</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">480*800</td>
<td align="center">720*1280</td>
<td align="center">1080*1920</td>
<td align="center">2160*3840</td>
</tr>
<tr>
<td>备注</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">HD高清</td>
<td align="center">FHD全高清</td>
<td align="center">UHD全高清</td>
</tr>
<tr>
<td>dp</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td>px</td>
<td align="center">0.75</td>
<td align="center">1</td>
<td align="center">1.5</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p><a href="https://www.pixplicity.com/dp-px-converter">参考链接</a></p>
<h2 id="常用尺寸"><a href="#常用尺寸" class="headerlink" title="常用尺寸"></a>常用尺寸</h2><ul>
<li>所有可操作元素最小点击区域尺寸<code>48dp*48dp</code>,图表大小则为<code>18*18dp</code></li>
<li>顶部状态栏高度:24dp</li>
<li>AppBar最小高度:56dp</li>
<li>低步导航栏高度:48dp</li>
<li>悬浮按钮尺寸:<code>56dp*56dp / 40*40dp</code></li>
<li>用户头像:<code>64*64dp / 40*40dp</code></li>
<li>小图标点击区域:<code>48*48</code></li>
<li>侧边抽屉到屏幕右边距离:56dp</li>
<li>卡片间距:8dp</li>
<li>分割线上下留白:8dp</li>
<li>大多元素的留白距离:16dp</li>
<li>屏幕左右对齐基线:16dp</li>
<li>文字左侧对齐基线:72dp<h2 id="UI尺寸工具类DisplayUtil-java"><a href="#UI尺寸工具类DisplayUtil-java" class="headerlink" title="UI尺寸工具类DisplayUtil.java"></a>UI尺寸工具类<code>DisplayUtil.java</code></h2></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DisplayUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = Class.class.getName();</span><br><span class="line"></span><br><span class="line">    private static int mScreenWidth = -1;</span><br><span class="line">    private static int mScreenHeight = -1;</span><br><span class="line">    private static float mDensity = -1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取屏幕宽度</span><br><span class="line">     * @param context</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getScreenWidth(Context context)&#123;</span><br><span class="line">        if(mScreenWidth &lt; 0)&#123;</span><br><span class="line">            init(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return mScreenWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取屏幕高度</span><br><span class="line">     * @param context</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getScreenHeight(Context context)&#123;</span><br><span class="line">        if(mScreenHeight &lt; 0)&#123;</span><br><span class="line">            init(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return mScreenHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static float getDensity(Context context)&#123;</span><br><span class="line">        if(mDensity &lt; 0)&#123;</span><br><span class="line">            init(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return mDensity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static void init(Context context)&#123;</span><br><span class="line">        DisplayMetrics dm =context.getResources().getDisplayMetrics();</span><br><span class="line">        mScreenWidth = dm.widthPixels;</span><br><span class="line">        mScreenHeight = dm.heightPixels;</span><br><span class="line">        mDensity = dm.density;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * dip转px</span><br><span class="line">     * @param context</span><br><span class="line">     * @param dipValue</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int dip2px(Context context, float dipValue)&#123;</span><br><span class="line">        if(mDensity &lt; 0)&#123;</span><br><span class="line">            init(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)(dipValue * mDensity + 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * px转dip</span><br><span class="line">     * @param context</span><br><span class="line">     * @param pxValue</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int px2dip(Context context, float pxValue)&#123;</span><br><span class="line">        if(mDensity &lt; 0)&#123;</span><br><span class="line">            init(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)(pxValue / mDensity + 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV修改ROI区域值时需注意数据类型</title>
    <url>/post/935cfe01.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍使用OpenCV在修改矩阵特定区域也就是ROI值的时候，需要注意的事项。如果类型错误，将得到错误的结果.</p>
<span id="more"></span>
<p>正式交代主题前，先看以下几个点.</p>
<h2 id="imread函数"><a href="#imread函数" class="headerlink" title="imread函数"></a><a href="http://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imread#Mat%20imread(const%20string&%20filename,%20int%20flags)">imread函数</a></h2><p>我们主要是关注第二个参数,有以下四种:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CV_LOAD_IMAGE_ANYDEPTH - If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit.</span><br><span class="line">CV_LOAD_IMAGE_COLOR - If set, always convert image to the color one</span><br><span class="line">CV_LOAD_IMAGE_GRAYSCALE - If set, always convert image to the grayscale one</span><br><span class="line">&gt;0 Return a 3-channel color image.</span><br></pre></td></tr></table></figure>
<p>默认下传的是<code>CV_LOAD_IMAGE_COLOR</code>,得到的Mat type为<code>CV_8UC3</code>,如果传的是<code>CV_LOAD_IMAGE_GRAYSCALE</code>则表示加载的是灰度图像，type为<code>CV_8UC1</code>。</p>
<h2 id="设置ROI"><a href="#设置ROI" class="headerlink" title="设置ROI"></a>设置ROI</h2><p>方式有大概有2种:</p>
<ol>
<li>拷贝构造函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat roi = Mat(gray, Rect(100, 0, 30, 30));</span><br></pre></td></tr></table></figure>
<p>当然上面也完全等价于下面这句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat roi(gray, Rect(100, 0, 30, 30));</span><br></pre></td></tr></table></figure>
<p>可能是写Java多的原因，我更喜欢前面的那种写法.<br>2. 使用操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat srcROI = src(Rect(0,0,src.cols/2,src.rows/2));  </span><br></pre></td></tr></table></figure>
<h2 id="Rect的使用"><a href="#Rect的使用" class="headerlink" title="Rect的使用"></a><a href="http://docs.opencv.org/2.4/modules/core/doc/basic_structures.html?highlight=cv_8uc1#rect">Rect</a>的使用</h2><p>最常见的一种构造方法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);</span><br></pre></td></tr></table></figure>
<p>其中x表示ROI区域的x坐标(横轴为X),也就是第几列的意思，y就不解释了。width表示ROI区域的宽度.</p>
<h2 id="Mat元素访问"><a href="#Mat元素访问" class="headerlink" title="Mat元素访问"></a>Mat元素访问</h2><p><a href="http://blog.csdn.net/xiaowei_cqu/article/details/19839019">链接</a>列举了13种访问方法，<a href="http://www.cnblogs.com/phillips/p/4484717.html">这里</a>又精简到3种，如果对效率没什么太高要求那么还是第一种用起来比较顺手:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i=0; i&lt;ROWS ; i++)  </span><br><span class="line"> &#123;  </span><br><span class="line">      for (int j=0; j&lt;COLS ; j++)  </span><br><span class="line">      &#123;  </span><br><span class="line">          img1.at&lt;float&gt;(i,j) = 3.2f;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的Mat.at<float>(i, j),其中i表示第几行，j表示第几列.</p>
<h2 id="修改特定区域的值"><a href="#修改特定区域的值" class="headerlink" title="修改特定区域的值"></a>修改特定区域的值</h2><p>目的就是要将roi区域灰度值置为0:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void clearMat(Mat a)&#123;</span><br><span class="line">    if(a.empty())&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i&lt;a.rows; i++)</span><br><span class="line">        for(int j = 0; j&lt;a.cols; j++)&#123;</span><br><span class="line">            a.at&lt;uchar&gt;(i, j) = 0;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    cout &lt;&lt; &quot;Hello, World!\n&quot;;</span><br><span class="line">    string path = &quot;/Users/yanzi/Pictures/lena.jpg&quot;;</span><br><span class="line">    Mat img = imread(path);</span><br><span class="line">    </span><br><span class="line">    //显示灰度图</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(img, gray, COLOR_RGBA2GRAY);</span><br><span class="line">    </span><br><span class="line">    Mat gray1 = imread(path, IMREAD_GRAYSCALE);</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">//    Mat roi = Mat(gray, Rect(100, 0, 30, 30));</span><br><span class="line">    Mat roi(gray, Rect(100, 0, 30, 30));</span><br><span class="line">    clearMat(roi);</span><br><span class="line">    </span><br><span class="line">    namedWindow(&quot;gray&quot;);</span><br><span class="line">    imshow(&quot;gray&quot;, gray);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将gray矩阵的那个rect区域弄成黑色，效果图如下:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170909-190218.jpg" alt="">可以看到运行的丝毫不差。注意我们在访问矩阵元素是是将其设为<code>uchar</code>,如果将其改为<code>int</code>看一下效果:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170909-190418.jpg" alt=""><br>起点是对的，但是宽度变成了需求的四倍。这是因为uchar只占一个字节，而int为4个字节.当错误的将其转为int后，就会发生实际修改的区域越位的情况。所以当修改Mat时一定格外注意.</p>
<p><a href="http://docs.opencv.org/2.4/modules/core/doc/basic_structures.html?highlight=cv_8uc1#sparsemat-depth">下面</a>是深度和取值范围的对应关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CV_8U - 8-bit unsigned integers ( 0..255 )</span><br><span class="line">CV_8S - 8-bit signed integers ( -128..127 )</span><br><span class="line">CV_16U - 16-bit unsigned integers ( 0..65535 )</span><br><span class="line">CV_16S - 16-bit signed integers ( -32768..32767 )</span><br><span class="line">CV_32S - 32-bit signed integers ( -2147483648..2147483647 )</span><br><span class="line">CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )</span><br><span class="line">CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )</span><br></pre></td></tr></table></figure>
<p>我们还要清楚这个depth和数据类型的对应关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mat_&lt;uchar&gt;---------CV_8U</span><br><span class="line">Mat&lt;char&gt;-----------CV_8S</span><br><span class="line">Nat_&lt;short&gt;---------CV_16S</span><br><span class="line">Mat_&lt;ushort&gt;--------CV_16U</span><br><span class="line">Mat_&lt;int&gt;-----------CV_32S</span><br><span class="line">Mat_&lt;float&gt;----------CV_32F</span><br><span class="line">Mat_&lt;double&gt;--------CV_64F</span><br></pre></td></tr></table></figure>
<p>这样就不会出错了。<br>再贴一段如果是三通道时的访问方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ROWS = 100; // height</span><br><span class="line"> 2 int COLS = 200; // width</span><br><span class="line"> 3 Mat img1(ROWS , COLS , CV_8UC3);  </span><br><span class="line"> 4   </span><br><span class="line"> 5 for (int i=0; i&lt;ROWS ; i++)  </span><br><span class="line"> 6 &#123;  </span><br><span class="line"> 7     for (int j=0; j&lt;COLS ; j++)  </span><br><span class="line"> 8     &#123;  </span><br><span class="line"> 9        img1.at&lt;vec3b&gt;(i,j)[0]= 3.2f;  // B 通道</span><br><span class="line">10        img1.at&lt;vec3b&gt;(i,j)[1]= 3.2f;  // G 通道</span><br><span class="line">11        img1.at&lt;vec3b&gt;(i,j)[2]= 3.2f;  // R 通道</span><br><span class="line">12     &#125;  </span><br><span class="line">13 &#125;                 </span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.cnblogs.com/dupuleng/articles/4072736.html">http://www.cnblogs.com/dupuleng/articles/4072736.html</a></li>
<li><a href="http://docs.opencv.org/2.4/modules/core/doc/basic_structures.html?highlight=cv_8uc1#sparsemat-depth">opencv2.4.13官方文档</a></li>
</ol>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用启动流程分析</title>
    <url>/post/c1c83cc.html</url>
    <content><![CDATA[<p><code>ActivityThread</code>是<code>Activity</code>里一个很重要的成员变量，俗称UI线程，也即应用的主线程,它自身有三个比较关键的成员变量，其中之一是<code>ApplicationThread</code>,在<code>ActivityThread</code>创建的时候作为全局变量被创建:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final ApplicationThread mAppThread = new ApplicationThread();</span><br><span class="line">final ApplicationThread mAppThread = new ApplicationThread();</span><br><span class="line">final Looper mLooper = Looper.myLooper();</span><br><span class="line">final H mH = new H();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>ApplicationThread</code>是<code>ActivityThread</code>里一个内部类，继承自<code>ApplicationThreadNative</code>,而<code>ApplicationThreadNative</code>又继承自<code>Binder</code>并<strong>implements</strong>了<code>IApplicationThread</code>接口(此处并没有真正实现)，<code>IApplicationThread</code>继承<code>IInterface</code>,定义了一系列操作应用的接口，用来和AMS进行通信,其中和Activity生命周期相关的几个关键函数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving,int configChanges, boolean dontReport) throws RemoteException;</span><br><span class="line"></span><br><span class="line">void scheduleStopActivity(IBinder token, boolean showWindow,int configChanges) throws RemoteException;</span><br><span class="line"></span><br><span class="line">void scheduleResumeActivity(IBinder token, int procState, boolean isForward, Bundle resumeArgs)throws RemoteException;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>IInterface.java</code>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IInterface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Retrieve the Binder object associated with this interface.</span><br><span class="line">     * You must use this instead of a plain cast, so that proxy objects</span><br><span class="line">     * can return the correct result.</span><br><span class="line">     */</span><br><span class="line">    public IBinder asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Binder.java</code>实现了<code>IBinder</code>接口，核心的<code>onTransact</code>函数和<code>transact</code>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean onTransact(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException &#123;</span><br><span class="line">        if (code == INTERFACE_TRANSACTION) &#123;</span><br><span class="line">            reply.writeString(getInterfaceDescriptor());</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (code == DUMP_TRANSACTION) &#123;</span><br><span class="line">            ParcelFileDescriptor fd = data.readFileDescriptor();</span><br><span class="line">            String[] args = data.readStringArray();</span><br><span class="line">            if (fd != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    dump(fd.getFileDescriptor(), args);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    IoUtils.closeQuietly(fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ........     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean transact(int code, Parcel data, Parcel reply,</span><br><span class="line">          int flags) throws RemoteException &#123;</span><br><span class="line">      if (false) Log.v(&quot;Binder&quot;, &quot;Transact: &quot; + code + &quot; to &quot; + this);</span><br><span class="line"></span><br><span class="line">      if (data != null) &#123;</span><br><span class="line">          data.setDataPosition(0);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean r = onTransact(code, data, reply, flags);</span><br><span class="line">      if (reply != null) &#123;</span><br><span class="line">          reply.setDataPosition(0);</span><br><span class="line">      &#125;</span><br><span class="line">      return r;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的<code>transact()</code>函数是<strong>final</strong>修饰，不可被子类重写，但<code>onTransact()</code>可以被重写。<br><code>ApplicationThreadNative</code>的主要功能就是重写了<code>onTransact</code>函数，根据不同的<code>code</code>路由给内部类<code>ApplicationThreadProxy</code>(实现了<code>IApplicationThread</code>接口),完成和binder通讯的部分.<br>也即真正实现<code>IApplicationThread</code>接口的有两个类：<code>ApplicationThread</code>和<code>ApplicationThreadProxy</code>,其中<code>ApplicationThread</code>负责通过<code>ActivityThread</code>最终控制<code>Activity</code>的生命周期，<code>ApplicationThreadProxy</code>负责对应功能与Binder通讯的部门。<br>也可以说<code>ApplicationThread</code>具有上面两部分功能，只不过按层次实现在不同类里.</p>
<p>以<code>schedulePauseActivity()</code>接口为例，<code>ApplicationThreadProxy</code>实现为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException &#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    data.writeInt(finished ? 1 : 0);</span><br><span class="line">    data.writeInt(userLeaving ? 1 :0);</span><br><span class="line">    data.writeInt(configChanges);</span><br><span class="line">    data.writeInt(dontReport ? 1 : 0);</span><br><span class="line">    mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationThread</code>对其实现为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void schedulePauseActivity(IBinder token, boolean finished,</span><br><span class="line">        boolean userLeaving, int configChanges, boolean dontReport) &#123;</span><br><span class="line">    int seq = getLifecycleSeq();</span><br><span class="line">    if (DEBUG_ORDER) Slog.d(TAG, &quot;pauseActivity &quot; + ActivityThread.this</span><br><span class="line">            + &quot; operation received seq: &quot; + seq);</span><br><span class="line">    sendMessage(</span><br><span class="line">            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">            token,</span><br><span class="line">            (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0),</span><br><span class="line">            configChanges,</span><br><span class="line">            seq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中sendMessage实现为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mH继承自<code>Handler</code>负责处理ApplicationThread发送到消息队列的消息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">         if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">         switch (msg.what) &#123;</span><br><span class="line">             case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                 final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                 r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                         r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                 handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">                 Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">             &#125; break;</span><br><span class="line">       .........      </span><br></pre></td></tr></table></figure>
<p>上面把<code>ActivityThread</code>、<code>ApplicationThread</code>、<code>ApplicationThreadProxy</code>、<code>ApplicationThreadNative</code>的关系说清楚了，下面接着看流程.</p>
<h2 id="step3–Instrumentation-execStartActivity"><a href="#step3–Instrumentation-execStartActivity" class="headerlink" title="step3–Instrumentation.execStartActivity"></a>step3–Instrumentation.execStartActivity</h2><p><code>Instrumentation</code>里的<code>execStartActivity()</code>核心代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, int requestCode, Bundle options) &#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != null ? target.onProvideReferrer() : null;</span><br><span class="line">      .........</span><br><span class="line">    try &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        int result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != null ? target.mEmbeddedID : null,</span><br><span class="line">                    requestCode, 0, null, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Failure from system&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键的是<code>int result = ActivityManagerNative.getDefault().startActivity(...)</code>,<code>ActivityManagerNative</code>在路径:<code>/frameworks/base/core/java/android/app/ActivityManagerNative.java</code>,其中的<code>getDefault()</code>函数返回内部的变量:<code>gDefault</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    protected IActivityManager create() &#123;</span><br><span class="line">            IBinder b = ServiceManager.getService(&quot;activity&quot;);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</span><br><span class="line">            &#125;</span><br><span class="line">            IActivityManager am = asInterface(b);</span><br><span class="line">            if (false) &#123;</span><br><span class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</span><br><span class="line">            &#125;</span><br><span class="line">            return am;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServiceManager</code>路径<code>/frameworks/base/core/java/android/os/ServiceManager.java</code>,它就是Android的ServiceManager进程，本身也是一个服务，内部通过一个HashMap类型<code>sCache</code>变量保存各种Service的Binder接口,如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;();</span><br><span class="line"></span><br><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service = sCache.get(name);</span><br><span class="line">            if (service != null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return getIServiceManager().getService(name);</span><br><span class="line">            &#125;</span><br><span class="line"> .........</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void addService(String name, IBinder service) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            getIServiceManager().addService(name, service, false);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in addService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从中可以看到gDefault实质是ActivityManagerService的远程接口,然后通过<code>asInterface</code>这个函数将一个Binder对象转为IActivityManager接口，并生成了一个<code>ActivityManagerProxy</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Cast a Binder object into an activity manager interface, generating</span><br><span class="line">  * a proxy if needed.</span><br><span class="line">  */</span><br><span class="line"> static public IActivityManager asInterface(IBinder obj) &#123;</span><br><span class="line">     if (obj == null) &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     IActivityManager in =</span><br><span class="line">         (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">     if (in != null) &#123;</span><br><span class="line">         return in;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return new ActivityManagerProxy(obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以最终又调到了ActivityManagerProxy.startActivity函数.<br>这里<code>ActivityManagerNative</code>和<code>ActivityManagerProxy</code>,与<code>ApplicationThreadNative</code>和<code>ApplicationThreadProxy</code>在实现模式上是一样的。</p>
<h2 id="step4–ActivityManagerProxy-startActivity"><a href="#step4–ActivityManagerProxy-startActivity" class="headerlink" title="step4–ActivityManagerProxy.startActivity"></a>step4–ActivityManagerProxy.startActivity</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ActivityManagerProxy implements IActivityManager</span><br><span class="line">&#123;</span><br><span class="line">    public ActivityManagerProxy(IBinder remote)</span><br><span class="line">    &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">            String resolvedType, IBinder resultTo, String resultWho, int requestCode,</span><br><span class="line">            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(caller != null ? caller.asBinder() : null);</span><br><span class="line">        ......data.writeString(callingPackage);</span><br><span class="line">        intent.writeToParcel(data, 0);</span><br><span class="line">        ...</span><br><span class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        int result = reply.readInt();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面说过在ActivityManagerProxy被创建的时候传进来一个IBinder对象，这个就是AMS的远程调用接口，也即<code>mRemote</code>变量.这里最核心的一句是:<code>mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0)</code>。</p>
<h2 id="step4–ActivityManagerService-startActivity"><a href="#step4–ActivityManagerService-startActivity" class="headerlink" title="step4–ActivityManagerService.startActivity"></a>step4–ActivityManagerService.startActivity</h2><p>上个步骤里的mRemote.transact()就是利用binder驱动进行跨进程通信的过程，在mRemote的onTransact函数里一定有个地方去响应<code>START_ACTIVITY_TRANSACTION</code>这个命令。</p>
<p><strong>注意:上面的步骤都是在初始应用程序A进程里，在onTransact时来到了AMS，也即AMS所在的SystemServer进程.</strong></p>
<p>我们直接到<code>ActivityManagerService</code>里去找.<br>源码在<code>/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</code>,它继承了上面的<code>ActivityManagerNative</code>,在其<code>onTransact</code>函数里找到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case START_ACTIVITY_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">            IBinder b = data.readStrongBinder();</span><br><span class="line">            IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">            String callingPackage = data.readString();</span><br><span class="line">           .............</span><br><span class="line">            int result = startActivity(........);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeInt(result);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了<code>startActivity</code>函数，但是<code>ActivityManagerNative</code>是个abstract类，并没有真正实现<code>IActivityManager</code>接口，其实现在其子类<code>ActivityManagerService</code>里。它又调了内部的<code>startActivityAsUser()</code>函数,最终又进到<code>mActivityStarter.startActivityMayWait()</code>函数里。</p>
<h2 id="step5–ActivityStarter-startActivityMayWait"><a href="#step5–ActivityStarter-startActivityMayWait" class="headerlink" title="step5–ActivityStarter.startActivityMayWait"></a>step5–ActivityStarter.startActivityMayWait</h2><p><strong>备注:此处往下的流程集中在<code>ActivityStackSupervisor</code>、<code>ActivityStack</code>、<code>ActivityStarter</code>比较复杂，只交代调用流程，不作太多解释.</strong><br><code>startActivityMayWait()</code>这个函数比较长，最终又调了内部的<code>startActivityLocked</code>里。<br>doPendingActivityLaunchesLocked—startActivityUnchecked,在<code>startActivityUnchecked</code>通过<code>mSupervisor.resumeFocusedStackTopActivityLocked()</code>,进到<code>ActivityStackSupervisor</code>,然后进到<code>ActivityStack.resumeTopActivityUncheckedLocked</code>,再调内部的<code>resumeTopActivityInnerLocked()</code>函数，再调内部的<code>startPausingLocked</code>函数,其中关键一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                        userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里<code>prev</code>类型为<code>ActivityRecord</code>,<code>app</code>类型为<code>ProcessRecord</code>,<code>thread</code>类型为<code>IApplicationThread</code>,即<code>prev.app.thread</code>是运行在<code>ActivityManagerService</code>进程里的``ApplicationThread<code>的远程调用接口</code>ApplicationThreadProxy`.</p>
<h2 id="step6–ApplicationThreadProxy-schedulePauseActivity"><a href="#step6–ApplicationThreadProxy-schedulePauseActivity" class="headerlink" title="step6–ApplicationThreadProxy.schedulePauseActivity"></a>step6–ApplicationThreadProxy.schedulePauseActivity</h2><p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      boolean userLeaving, int configChanges, boolean dontReport) throws RemoteException &#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    ..........</span><br><span class="line">    data.writeInt(dontReport ? 1 : 0);</span><br><span class="line">    mRemote.transact(SCHEDULE_PAUSE_ACTIVITY_TRANSACTION, data, null,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过进程间通信，来到<code>ApplicationThreadNative</code>里的<code>onTransact</code>函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags)</span><br><span class="line">            throws RemoteException &#123;</span><br><span class="line">        switch (code) &#123;</span><br><span class="line">        case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">            IBinder b = data.readStrongBinder();</span><br><span class="line">            ......</span><br><span class="line">            schedulePauseActivity(b, finished, userLeaving, configChanges, dontReport);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="step7–ApplicationThread-schedulePauseActivity"><a href="#step7–ApplicationThread-schedulePauseActivity" class="headerlink" title="step7–ApplicationThread.schedulePauseActivity"></a>step7–ApplicationThread.schedulePauseActivity</h2><p><strong>注意:经过上面步骤里的onTransact来到了Launcher进程里.</strong><br><code>schedulePauseActivity()</code>通过<code>ActivityThread</code>里的Handler<code>mH</code>,将消息转发至UI线程里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case PAUSE_ACTIVITY: &#123;</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;);</span><br><span class="line">                  SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">                  handlePauseActivity((IBinder) args.arg1, false,</span><br><span class="line">                          (args.argi1 &amp; USER_LEAVING) != 0, args.argi2,</span><br><span class="line">                          (args.argi1 &amp; DONT_REPORT) != 0, args.argi3);</span><br><span class="line">                  maybeSnapshot();</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">              &#125; break;</span><br></pre></td></tr></table></figure>
<p>进到了<code>handlePauseActivity()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void handlePauseActivity(IBinder token, boolean finished,</span><br><span class="line">            boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line"></span><br><span class="line">            performPauseActivity(token, finished, r.isPreHoneycomb(), &quot;handlePauseActivity&quot;);</span><br><span class="line"></span><br><span class="line">            // Tell the activity manager we have paused.</span><br><span class="line">            if (!dontReport) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">                &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                    throw ex.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数首先将Binder引用token转换成ActivityRecord的远程接口ActivityClientRecord，然后做了三个事情：</p>
<ol>
<li>如果userLeaving为true，则通过调用performUserLeavingActivity函数来调用Activity.onUserLeaveHint通知Activity，用户要离开它了；</li>
<li>调用performPauseActivity函数来调用Activity.onPause函数，我们知道，在Activity的生命周期中，当它要让位于其它的Activity时，系统就会调用它的onPause函数；</li>
<li>它通知ActivityManagerService，这个Activity已经进入Paused状态了，ActivityManagerService现在可以完成未竟的事情，即启动MainActivity了。<br><code>ActivityManagerProxy</code>里<code>activityPaused</code>函数如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void activityPaused(IBinder token) throws RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        mRemote.transact(ACTIVITY_PAUSED_TRANSACTION, data, reply, 0);</span><br><span class="line">        reply.readException();</span><br><span class="line">        data.recycle();</span><br><span class="line">        reply.recycle();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="step8–ActivityManagerService-activityPaused"><a href="#step8–ActivityManagerService-activityPaused" class="headerlink" title="step8–ActivityManagerService.activityPaused"></a>step8–ActivityManagerService.activityPaused</h2></li>
</ol>
<p><strong>备注:又来到了AMS所在的进程！！！</strong><br>上面的步骤经过进程间通信来到ActivityManagerNative里的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case ACTIVITY_PAUSED_TRANSACTION: &#123;</span><br><span class="line">           data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">           IBinder token = data.readStrongBinder();</span><br><span class="line">           activityPaused(token);</span><br><span class="line">           reply.writeNoException();</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>调到AMS的<code>activityPaused()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void activityPaused(IBinder token) &#123;</span><br><span class="line">       final long origId = Binder.clearCallingIdentity();</span><br><span class="line">       synchronized(this) &#123;</span><br><span class="line">           ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">           if (stack != null) &#123;</span><br><span class="line">               stack.activityPausedLocked(token, false);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Binder.restoreCallingIdentity(origId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="step9–ActivityStack-activityPausedLocked"><a href="#step9–ActivityStack-activityPausedLocked" class="headerlink" title="step9–ActivityStack.activityPausedLocked"></a>step9–ActivityStack.activityPausedLocked</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void activityPausedLocked(IBinder token, boolean timeout) &#123;</span><br><span class="line">        if (DEBUG_PAUSE) Slog.v(TAG_PAUSE,</span><br><span class="line">            &quot;Activity paused: token=&quot; + token + &quot;, timeout=&quot; + timeout);</span><br><span class="line"></span><br><span class="line">        final ActivityRecord r = isInStackLocked(token);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);</span><br><span class="line">            if (mPausingActivity == r) &#123;</span><br><span class="line">                if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r</span><br><span class="line">                        + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));</span><br><span class="line">                completePauseLocked(true, null);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>调到了内部函数<code>completePauseLocked()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">completePauseLocked()&#123;</span><br><span class="line">.......</span><br><span class="line">    if (resumeNext) &#123;</span><br><span class="line">            final ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">            if (!mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调了<code>ActivityStackSupervisor</code>里的<code>resumeFocusedStackTopActivityLocked</code>函数.</p>
<h2 id="step10–ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#step10–ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="step10–ActivityStackSupervisor.resumeFocusedStackTopActivityLocked"></a>step10–ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</h2><p>通过之前流程可以知道，当前在堆栈顶端的Activity为我们即将要启动的Activity,而Launcher对应的Activity已经被paused了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">        if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">        if (r == null || r.state != RESUMED) &#123;</span><br><span class="line">            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后调用ActivityStack的resumeTopActivityUncheckedLocked()函数.</p>
<h2 id="step10–ActivityStack-resumeTopActivityUncheckedLocked"><a href="#step10–ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="step10–ActivityStack.resumeTopActivityUncheckedLocked"></a>step10–ActivityStack.resumeTopActivityUncheckedLocked</h2><p>在<code>resumeTopActivityUncheckedLocked</code>函数里调了自身的<code>resumeTopActivityInnerLocked</code>,然后调自身的<code>resumeTopActivityInnerLocked</code>,最终调了<code>mStackSupervisor.startSpecificActivityLocked(next, true, true)</code>.</p>
<h2 id="step11–ActivityStackSupervisor-startSpecificActivityLocked"><a href="#step11–ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="step11–ActivityStackSupervisor.startSpecificActivityLocked"></a>step11–ActivityStackSupervisor.startSpecificActivityLocked</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">                &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br></pre></td></tr></table></figure>
<p>调到了<code>ActivityManagerService</code>里.</p>
<h2 id="step12–ActivityManagerService-startProcessLocked"><a href="#step12–ActivityManagerService-startProcessLocked" class="headerlink" title="step12–ActivityManagerService.startProcessLocked"></a>step12–ActivityManagerService.startProcessLocked</h2><p>此函数里核心代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;);</span><br><span class="line">            Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, entryPointArgs);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: returned from zygote!&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="step13–Process-start"><a href="#step13–Process-start" class="headerlink" title="step13–Process.start()"></a>step13–Process.start()</h2><p>最终来到了Process(<code>./frameworks/base/core/java/android/os/Process.java</code>),调用自身<code>startViaZygote()</code>,在这个函数里最后一句是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br></pre></td></tr></table></figure>
<p>首先通过<code>openZygoteSocketIfNeeded</code>,建AMS进程和Zygote进程通过socket进行跨进程通信的连接.<br>然后<code>zygoteSendArgsAndGetResult()</code>这个函数向zygote进程发送一个参数列表，zygote进程会启动一个新的子进程并返回该子进程的pid号。<br>请求的参数中有一个字符串，它的值是“android.app.ActivityThread”。现在该回到zygote处理请求那块去看看了——就是runSelectLoop函数，具体在<code>ZygoteInit</code>里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123;</span><br><span class="line">.........</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            StructPollfd[] pollFds = new StructPollfd[fds.size()];</span><br><span class="line">            for (int i = 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = new StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (short) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Os.poll(pollFds, -1);</span><br><span class="line">            &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">                throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">                if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i == 0) &#123;</span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    boolean done = peers.get(i).runOnce();</span><br><span class="line">                    if (done) &#123;</span><br><span class="line">                        peers.remove(i);</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到里面是一个while循环，一直在监听socket发来的信息，最终调用了<code>ZygoteConnection</code>里的<code>runOnce</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                    parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                    parsedArgs.appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line">.......</span><br><span class="line">if (pid == 0) &#123;</span><br><span class="line">                // in child</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = null;</span><br><span class="line">                handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line"></span><br><span class="line">                // should never get here, the child is expected to either</span><br><span class="line">                // throw ZygoteInit.MethodAndArgsCaller or exec().</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里最终调到了Zygote的两个关键函数<code>forkAndSpecialize</code>函数，然后通过JNI调用了<code>nativeForkAndSpecialize</code>函数,这个函数最终fork了一个子进程,暂时忽略.<br>另外一个函数是<code>handleChildProc()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (parsedArgs.invokeWith != null) &#123;</span><br><span class="line">           WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                   parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                   VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                   pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                   parsedArgs.remainingArgs, null /* classLoader */);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里会走到<code>RuntimeInit.zygoteInit</code>,然后调内部的<code>applicationInit()</code>函数,再调内部的<code>invokeStaticMain()</code>函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">            throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            cl = Class.forName(className, true, classLoader);</span><br><span class="line">        &#125; </span><br><span class="line">......</span><br><span class="line">        Method m;</span><br><span class="line">        try &#123;</span><br><span class="line">            m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，上述代码完成了一个反射的功能，去加载传进来的类名的<code>main</code>方法。在打开应用过程中，这个类名就是<code>android.app.ActivityThread</code></p>
<h2 id="step14–ActivityThread-main"><a href="#step14–ActivityThread-main" class="headerlink" title="step14–ActivityThread.main()"></a>step14–ActivityThread.main()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line"></span><br><span class="line">        if (sMainThreadHandler == null) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br></pre></td></tr></table></figure>
<p>在main函数里，创建了<code>ActivityThread</code>和主Ui线程Handler,然后调用它的attach函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            try &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread);</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                throw ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>mgr</code>就是<code>ActivityManagerService</code>的远程接口<code>ActivityManagerProxy</code>的<code>attachApplication</code>函数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void attachApplication(IApplicationThread app) throws RemoteException</span><br><span class="line">   &#123;</span><br><span class="line">       Parcel data = Parcel.obtain();</span><br><span class="line">       Parcel reply = Parcel.obtain();</span><br><span class="line">       data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">       data.writeStrongBinder(app.asBinder());</span><br><span class="line">       mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);</span><br><span class="line">       reply.readException();</span><br><span class="line">       data.recycle();</span><br><span class="line">       reply.recycle();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里传进来的参数就是刚刚创建进程的远程调用接口,将其传给AMS。通过跨进程通讯，来到了<code>ActivityManagerService</code>的<code>attachApplication</code>函数。</p>
<h2 id="step15–ActivityManagerService-attachApplication"><a href="#step15–ActivityManagerService-attachApplication" class="headerlink" title="step15–ActivityManagerService.attachApplication()"></a>step15–ActivityManagerService.attachApplication()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (normalMode) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                   didSomething = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">               badApp = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这里进到了<code>attachApplicationLocked</code>函数.</p>
<h2 id="step16–ActivityStackSupervisor-attachApplicationLocked"><a href="#step16–ActivityStackSupervisor-attachApplicationLocked" class="headerlink" title="step16–ActivityStackSupervisor.attachApplicationLocked()"></a>step16–ActivityStackSupervisor.attachApplicationLocked()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">                if (hr != null) &#123;</span><br><span class="line">                    if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                            &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            if (realStartActivityLocked(hr, app, true, true)) &#123;</span><br><span class="line">                                didSomething = true;</span><br><span class="line">                            .....</span><br></pre></td></tr></table></figure>
<p>这里先调ActivityStack的topRunningActivityLocked，然后再调自己的<code>realStartActivityLocked</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,</span><br><span class="line">                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),</span><br><span class="line">                    new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br></pre></td></tr></table></figure>
<p>这里app.thread最终进到了<code>ApplicationThreadProxy</code>的<code>scheduleLaunchActivity</code>函数中。</p>
<h2 id="step17–ApplicationThreadProxy-scheduleLaunchActivity"><a href="#step17–ApplicationThreadProxy-scheduleLaunchActivity" class="headerlink" title="step17–ApplicationThreadProxy.scheduleLaunchActivity()"></a>step17–ApplicationThreadProxy.scheduleLaunchActivity()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null,</span><br><span class="line">               IBinder.FLAG_ONEWAY);</span><br></pre></td></tr></table></figure>
<p>AMS通过Binder通信，告诉<code>SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION</code>，进到了<code>scheduleLaunchActivity</code></p>
<h2 id="step18–ApplicationThreadProxy-scheduleLaunchActivity"><a href="#step18–ApplicationThreadProxy-scheduleLaunchActivity" class="headerlink" title="step18–ApplicationThreadProxy.scheduleLaunchActivity()"></a>step18–ApplicationThreadProxy.scheduleLaunchActivity()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident...)</span><br><span class="line">      sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>来到了Handler(H)的handleMessage函数里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                &#125; break;</span><br></pre></td></tr></table></figure>
<p>调用自己的<code>handleLaunchActivity</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123;</span><br><span class="line">......</span><br><span class="line">        Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">           .....</span><br><span class="line">            handleResumeActivity(r.token, false, r.isForward,</span><br><span class="line">                    !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">                    ....</span><br><span class="line">                performPauseActivityIfNeeded(r, reason);</span><br></pre></td></tr></table></figure>
<p>在<code>handleLaunchActivity</code>函数里主要干了两个重要事情,第一是通过<code>performLaunchActivity</code>去加载一个<code>Activity</code>,然后调用它的<code>onCreate</code>方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">        if (r.activityInfo.targetActivity != null) &#123;</span><br><span class="line">            component = new ComponentName(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Activity activity = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">        &#125; .....</span><br><span class="line">        try &#123;</span><br><span class="line">            Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = new Configuration(mCompatConfiguration);</span><br><span class="line">               ....</span><br><span class="line">                activity.attach(appContext, this, getInstrumentation(), r)</span><br><span class="line">                ....</span><br><span class="line">                if (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>performLaunchActivity</code>函数里，先通过类加载器创建一个<code>Activity</code>对象，然后创建<code>Application</code>对象,调用<code>Activity</code>的<code>attach()</code>,再通过<code>mInstrumentation.callActivityOnCreate</code>调Activity的<code>onCreate</code>。然后回到<code>handleLaunchActivity</code>函数，执行<code>handleResumeActivity</code>,即调Activity的<code>onResume()</code>生命周期。终于，新打开的<code>Activity</code>启动起来了!!!</p>
<h2 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h2><p>整个应用程序的启动过程要执行很多步骤，但是整体来看，主要分为以下五个阶段：</p>
<ol>
<li><p>Launcher通过Binder进程间通信机制通知AMS，它要启动一个Activity；</p>
</li>
<li><p>AMS通过Binder进程间通信机制通知Launcher进入Paused状态；</p>
</li>
<li><p>Launcher通过Binder进程间通信机制通知AMS它已经准备就绪进入Paused状态，于是AMS就创建一个新的进程，用来启动一个ActivityThread实例，即将要启动的Activity就是在这个ActivityThread实例中运行；</p>
</li>
<li><p>ActivityThread通过Binder进程间通信机制将一个ApplicationThread类型的Binder对象传递给AMS，以便以后AMS能够通过这个Binder对象和它进行通信；</p>
</li>
<li><p>AMS通过Binder进程间通信机制通知ActivityThread，现在一切准备就绪，它可以真正执行Activity的启动操作了。</p>
</li>
</ol>
<h2 id="调用流程图"><a href="#调用流程图" class="headerlink" title="调用流程图"></a>调用流程图</h2><p><img src="http://image.yangq.me/blog/history/16-7-5/activityStart.png" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab里double和uint8对imshow函数的影响</title>
    <url>/post/a525c216.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文介绍double和uint8两种数据类型对imshow函数造成的影响，如果使用不当用imshow函数显示double类型数据时将得到二值化黑白图像的效果。</p>
<span id="more"></span>
<h2 id="double和uint8差异"><a href="#double和uint8差异" class="headerlink" title="double和uint8差异"></a>double和uint8差异</h2><p>在matlab里<code>imread</code>之后默认是unit8类型的矩阵，即范围为0-255.但是很多图像变化中是需要数据类型为double的，这就需要将unit8通过<code>double()</code>转换即可，经过转换后数字没变，即原来是200则会变成200.0，仅仅是类型发生变化。但是对imshow函数而言，如果数据是double，它会认为图像正常区间是0-1,即0是黑，1是白,而超过1的都会认为是上限值1，即白色. 下面上一个代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clc;</span><br><span class="line">path = &#x27;/Users/yanzi/Pictures/lena.jpg&#x27;;</span><br><span class="line">image = imread(path);</span><br><span class="line">gray = rgb2gray(image);</span><br><span class="line">figure, imshow(gray), title(&#x27;gray&#x27;);</span><br><span class="line"></span><br><span class="line">gray2 = double(gray);</span><br><span class="line">gray2(1:10, 1:10)=0;</span><br><span class="line">figure, imshow(gray2), title(&#x27;gray2&#x27;);</span><br><span class="line"></span><br><span class="line">gray3 = im2double(gray);</span><br><span class="line">figure, imshow(gray3), title(&#x27;gray3&#x27;);</span><br></pre></td></tr></table></figure>
<p>其中gray是原图像，gray2是用double转换的，转换后可以看到它的数值没发生变化:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170909-171157.jpg" alt=""><br>上面的10*10是为了故意看到效果，设成了0，显示图像如下:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170909-171329.jpg" alt=""><br>最左边是原始灰度图像，中间是转double之后的，可以看到除了设0的那部分是黑之外，其他全是白的。</p>
<h2 id="im2double"><a href="#im2double" class="headerlink" title="im2double"></a>im2double</h2><p>注意到上图最右边的图像，显示也是正常的，它的数值范围是:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170909-171516.jpg" alt=""><br>可以看到im2double能将0-255范围内的unit8数据转成double类型的0-1范围内的数据，且能显示正常.</p>
<h2 id="互相转换"><a href="#互相转换" class="headerlink" title="互相转换"></a>互相转换</h2><ol>
<li>假设原始矩阵为uint8矩阵，如果你通过<code>double()</code>转成了double,那么你转回来只需通过<code>uint8()</code>即可。</li>
<li>如果你通过<code>im2double</code>转成了0-1区间的double，想转回去的话通过<code>im2uint8()</code>就能得到0-255范围的uint8数据.</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.csdn.net/fx677588/article/details/53301740">http://blog.csdn.net/fx677588/article/details/53301740</a></li>
</ul>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>RePlugin研究一:基础接入教程</title>
    <url>/post/98c4f5c4.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode刷题进展</title>
    <url>/post/3149820c.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>leetcode算法部分共有 <strong>1118</strong>道题 <strong>38</strong>个标签，本文按照leetcode的标签进行分类，跟踪自己刷题进展。</p>
<span id="more"></span>



<h2 id="一-数组-7-189"><a href="#一-数组-7-189" class="headerlink" title="一.数组(7/189)"></a>一.数组(7/189)</h2><h3 id="1-两数之和-简单"><a href="#1-两数之和-简单" class="headerlink" title="1. 两数之和(简单)"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和(简单)</a></h3><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h3><h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h3><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h3><h3 id="259-较小的三数之和-会员题"><a href="#259-较小的三数之和-会员题" class="headerlink" title="259. 较小的三数之和(会员题)"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/">259. 较小的三数之和(会员题)</a></h3><h3 id="277-搜寻名人-会员题"><a href="#277-搜寻名人-会员题" class="headerlink" title="277. 搜寻名人(会员题)"></a><a href="https://leetcode-cn.com/problems/find-the-celebrity/">277. 搜寻名人(会员题)</a></h3><h2 id="二-动态规划-7-149"><a href="#二-动态规划-7-149" class="headerlink" title="二.动态规划(7/149)"></a>二.动态规划(7/149)</h2><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h3><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h3><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><h3 id="256-粉刷房子-会员题"><a href="#256-粉刷房子-会员题" class="headerlink" title="256. 粉刷房子(会员题)"></a><a href="https://leetcode-cn.com/problems/paint-house/">256. 粉刷房子(会员题)</a></h3><h3 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276. 栅栏涂色"></a><a href="https://leetcode-cn.com/problems/paint-fence/">276. 栅栏涂色</a></h3><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><h2 id="三-数学-0-142"><a href="#三-数学-0-142" class="headerlink" title="三.数学(0/142)"></a>三.数学(0/142)</h2><h2 id="四-字符串-3-138"><a href="#四-字符串-3-138" class="headerlink" title="四.字符串(3/138)"></a>四.字符串(3/138)</h2><h3 id="271-字符串的编码与解码-中等"><a href="#271-字符串的编码与解码-中等" class="headerlink" title="271. 字符串的编码与解码(中等)"></a><a href="https://leetcode-cn.com/problems/encode-and-decode-strings/">271. 字符串的编码与解码(中等)</a></h3><h3 id="344-反转字符串-简单"><a href="#344-反转字符串-简单" class="headerlink" title="344. 反转字符串(简单)"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串(简单)</a></h3><h3 id="345-反转字符串中的元音字母-简单"><a href="#345-反转字符串中的元音字母-简单" class="headerlink" title="345. 反转字符串中的元音字母(简单)"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母(简单)</a></h3><h2 id="五-树-0-118"><a href="#五-树-0-118" class="headerlink" title="五.树(0/118)"></a>五.树(0/118)</h2><h2 id="六-哈希表-0-113"><a href="#六-哈希表-0-113" class="headerlink" title="六.哈希表(0/113)"></a>六.哈希表(0/113)</h2><h2 id="七-深度优先搜索-0-106"><a href="#七-深度优先搜索-0-106" class="headerlink" title="七.深度优先搜索(0/106)"></a>七.深度优先搜索(0/106)</h2><h2 id="八-二分查找-0-72"><a href="#八-二分查找-0-72" class="headerlink" title="八.二分查找(0/72)"></a>八.二分查找(0/72)</h2><h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/">287. 寻找重复数</a></h3><p>参考：</p>
<ul>
<li><a href="https://github.com/grandyang/leetcode/issues/287">https://github.com/grandyang/leetcode/issues/287</a></li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">十分好用的二分查找法模板</a></li>
</ul>
<h2 id="九-贪心算法-0-59"><a href="#九-贪心算法-0-59" class="headerlink" title="九.贪心算法(0/59)"></a>九.贪心算法(0/59)</h2><h2 id="十-双指针-0-57"><a href="#十-双指针-0-57" class="headerlink" title="十.双指针(0/57)"></a>十.双指针(0/57)</h2><h2 id="十一-广度优先搜索-0-51"><a href="#十一-广度优先搜索-0-51" class="headerlink" title="十一.广度优先搜索(0/51)"></a>十一.广度优先搜索(0/51)</h2><h2 id="十二-栈-0-50"><a href="#十二-栈-0-50" class="headerlink" title="十二.栈(0/50)"></a>十二.栈(0/50)</h2><h2 id="十三-回溯算法-0-45"><a href="#十三-回溯算法-0-45" class="headerlink" title="十三.回溯算法(0/45)"></a>十三.回溯算法(0/45)</h2><h2 id="十四-设计-0-40"><a href="#十四-设计-0-40" class="headerlink" title="十四.设计(0/40)"></a>十四.设计(0/40)</h2><h2 id="十五-链表-0-36"><a href="#十五-链表-0-36" class="headerlink" title="十五.链表(0/36)"></a>十五.链表(0/36)</h2><h2 id="十六-排序-0-36"><a href="#十六-排序-0-36" class="headerlink" title="十六.排序(0/36)"></a>十六.排序(0/36)</h2><h2 id="十七-位运算-0-34"><a href="#十七-位运算-0-34" class="headerlink" title="十七.位运算(0/34)"></a>十七.位运算(0/34)</h2><h2 id="十八-图-0-34"><a href="#十八-图-0-34" class="headerlink" title="十八.图(0/34)"></a>十八.图(0/34)</h2><h2 id="十九-堆-0-34"><a href="#十九-堆-0-34" class="headerlink" title="十九.堆(0/34)"></a>十九.堆(0/34)</h2><h2 id="二十-并查集-0-27"><a href="#二十-并查集-0-27" class="headerlink" title="二十.并查集(0/27)"></a>二十.并查集(0/27)</h2><h2 id="二十一-Sliding-Window-0-19"><a href="#二十一-Sliding-Window-0-19" class="headerlink" title="二十一.Sliding Window(0/19)"></a>二十一.Sliding Window(0/19)</h2><h2 id="二十二-分治算法-0-18"><a href="#二十二-分治算法-0-18" class="headerlink" title="二十二.分治算法(0/18)"></a>二十二.分治算法(0/18)</h2><h2 id="二十三-字典树-0-17"><a href="#二十三-字典树-0-17" class="headerlink" title="二十三.字典树(0/17)"></a>二十三.字典树(0/17)</h2><h2 id="二十四-递归-0-14"><a href="#二十四-递归-0-14" class="headerlink" title="二十四.递归(0/14)"></a>二十四.递归(0/14)</h2><h2 id="二十五-Orderd-Map-0-10"><a href="#二十五-Orderd-Map-0-10" class="headerlink" title="二十五.Orderd Map(0/10)"></a>二十五.Orderd Map(0/10)</h2><h2 id="二十六-线段树-0-10"><a href="#二十六-线段树-0-10" class="headerlink" title="二十六.线段树(0/10)"></a>二十六.线段树(0/10)</h2><h2 id="二十七-队列-0-9"><a href="#二十七-队列-0-9" class="headerlink" title="二十七.队列(0/9)"></a>二十七.队列(0/9)</h2><h2 id="二十八-极小化极大-0-8"><a href="#二十八-极小化极大-0-8" class="headerlink" title="二十八.极小化极大(0/8)"></a>二十八.极小化极大(0/8)</h2><h2 id="二十九-树状数组-0-6"><a href="#二十九-树状数组-0-6" class="headerlink" title="二十九.树状数组(0/6)"></a>二十九.树状数组(0/6)</h2><h2 id="三十-Random-0-6"><a href="#三十-Random-0-6" class="headerlink" title="三十.Random(0/6)"></a>三十.Random(0/6)</h2><h2 id="三十一-拓扑排序-0-5"><a href="#三十一-拓扑排序-0-5" class="headerlink" title="三十一.拓扑排序(0/5)"></a>三十一.拓扑排序(0/5)</h2><h2 id="三十二-脑筋急转弯-0-4"><a href="#三十二-脑筋急转弯-0-4" class="headerlink" title="三十二.脑筋急转弯(0/4)"></a>三十二.脑筋急转弯(0/4)</h2><h2 id="三十三-几何-0-3"><a href="#三十三-几何-0-3" class="headerlink" title="三十三.几何(0/3)"></a>三十三.几何(0/3)</h2><h2 id="三十四-Line-Sweep-0-3"><a href="#三十四-Line-Sweep-0-3" class="headerlink" title="三十四.Line Sweep(0/3)"></a>三十四.Line Sweep(0/3)</h2><h2 id="三十五-Rejection-Samping-0-2"><a href="#三十五-Rejection-Samping-0-2" class="headerlink" title="三十五.Rejection Samping(0/2)"></a>三十五.Rejection Samping(0/2)</h2><h2 id="三十六-蓄水池抽样-0-2"><a href="#三十六-蓄水池抽样-0-2" class="headerlink" title="三十六.蓄水池抽样(0/2)"></a>三十六.蓄水池抽样(0/2)</h2><h2 id="三十七-二叉搜索树-0-1"><a href="#三十七-二叉搜索树-0-1" class="headerlink" title="三十七.二叉搜索树(0/1)"></a>三十七.二叉搜索树(0/1)</h2><h2 id="三十八-记忆化-0-1"><a href="#三十八-记忆化-0-1" class="headerlink" title="三十八.记忆化(0/1)"></a>三十八.记忆化(0/1)</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/grandyang/leetcode/blob/master/README-CN.md">grandyang/leetcode</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(10)-搜寻名人</title>
    <url>/post/92de9a1a.html</url>
    <content><![CDATA[<h2 id="277-搜寻名人-会员题"><a href="#277-搜寻名人-会员题" class="headerlink" title="277. 搜寻名人(会员题)"></a><a href="https://leetcode-cn.com/problems/find-the-celebrity/">277. 搜寻名人(会员题)</a></h2><p>假设你是一个专业的狗仔，参加了一个n人派对，其中每个人被从0到n-1 标号。在这个派对人群当中可能存在一位 “名人”。所谓 “名人” 的定义是：其他所有n-1个人都认识他/她，而他/她并不认识其他任何人。</p>
<span id="more"></span>
<p>现在你想要确认这个“名人”是谁，或者确定这里没有“名人”。而你唯一能做的就是问诸如“A 你好呀，请问你认不认识 B呀？”的问题，以确定A是否认识 B。你需要在（渐近意义上）尽可能少的问题内来确定这位 “名人”是谁（或者确定这里没有“名人”）。在本题中，你可以使用辅助函数<code>bool knows(a, b)</code>获取到 A 是否认识 B。请你来实现一个函数<code>int findCelebrity(n)</code>。</p>
<p>派对最多只会有一个 “名人” 参加。若 “名人” 存在，请返回他/她的编号；若 “名人” 不存在，请返回 -1。<br><img src="https://i.loli.net/2019/10/02/r63ZeHGWD7v5FQ1.png" alt="屏幕快照 2019-10-02 下午7.12.22.png"></p>
<p><img src="https://i.loli.net/2019/10/02/MaKe8AGrh7LZRd9.png" alt="屏幕快照 2019-10-02 下午7.14.22.png"></p>
<h2 id="解法1（暴力破解）"><a href="#解法1（暴力破解）" class="headerlink" title="解法1（暴力破解）"></a>解法1（暴力破解）</h2><p>从0到n-1，假设其中一个数是名人，然后判断是否满足以下两个条件：</p>
<ol>
<li>别人都认识他；</li>
<li>他除自己外不认识别人<br>代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution extends Relation &#123;</span><br><span class="line">    public int findCelebrity(int n) &#123;</span><br><span class="line">        int result = -1;</span><br><span class="line">        boolean isFail = false;</span><br><span class="line">        for (int mingren = 0; mingren &lt; n; mingren++)&#123;</span><br><span class="line">            int others = 0, count = 0;</span><br><span class="line">            while (mingren == others || (knows(others, mingren) &amp;&amp; !knows(mingren, others) &amp;&amp; others &lt; n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">                // 包括自己名人有n个认识</span><br><span class="line">                if (count == n)&#123;</span><br><span class="line">                    return mingren;</span><br><span class="line">                &#125;</span><br><span class="line">            others++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意这里假设mingren后，找其他人的时候一定是从头也就是0开始找，不存在从<code>mingren + 1</code>开始找这个说法。上述算法耗时11ms。</p>
<h2 id="贪心算法（优化后）"><a href="#贪心算法（优化后）" class="headerlink" title="贪心算法（优化后）"></a>贪心算法（优化后）</h2><p>先假设第一个数就是名人，然后如果他认识别人，那就当其他人是名人。如果存在名人，则这个mingren只满足中间交换时i之后的人他不认识，而i之前的还要再确保一下。所以出了循环后针对修正后的名人，看看是不是满足条件。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution extends Relation &#123;</span><br><span class="line">    public int findCelebrity(int n) &#123;</span><br><span class="line">        int mingren = 0;</span><br><span class="line">        for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">            if (knows(mingren, i))&#123;</span><br><span class="line">                mingren = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int j = 0; j&lt;n; j++)&#123;</span><br><span class="line">            if (j != mingren &amp;&amp; (knows(mingren, j) || !knows(j, mingren)))&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mingren;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后耗时8ms。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/JuiceZhou/Leetcode/blob/master/java/array/$277_FindTheCelebrity.java">暴力法</a></li>
<li><a href="https://leetcode-cn.com/problems/find-the-celebrity/solution/277-sou-xun-ming-ren-by-guohaoding/">官方解法</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(1)-两数之和</title>
    <url>/post/a28dc3f0.html</url>
    <content><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<span id="more"></span>
<h2 id="第一种做法：暴力破解"><a href="#第一种做法：暴力破解" class="headerlink" title="第一种做法：暴力破解"></a>第一种做法：暴力破解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.yangq.test;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] results = new int[] &#123;0, 0&#125;;</span><br><span class="line">        for (int i =0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = i+1; j &lt; nums.length; j++) &#123;</span><br><span class="line">                if (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    results[0] = i;</span><br><span class="line">                    results[1] = j; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return results;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)，空间复杂度O(1)。</p>
<h2 id="第二种做法-一遍哈希"><a href="#第二种做法-一遍哈希" class="headerlink" title="第二种做法:一遍哈希"></a>第二种做法:一遍哈希</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; data = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i&lt; nums.length; i++) &#123;</span><br><span class="line">            int diff = target - nums[i];</span><br><span class="line">            if (data.containsKey(diff)) &#123;</span><br><span class="line">                return new int[] &#123;i, data.get(diff)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            data.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;can&#x27;t found&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(n)，我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)的时间。</p>
</li>
<li><p>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(11)-爬楼梯</title>
    <url>/post/41a8f423.html</url>
    <content><![CDATA[<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h2><p>假设你正在爬楼梯。需要n阶你才能到达楼顶。每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定n是一个正整数。</p>
<span id="more"></span>
<p><strong>示例1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if (n == 1 || n == 2)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int step[] = new int[n+1];</span><br><span class="line">        step[1] = 1;</span><br><span class="line">        step[2] = 2;</span><br><span class="line">        for (int i = 3; i &lt; n+1; i++)&#123;</span><br><span class="line">            step[i] = step[i-1] + step[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return step[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>需要识别出来这是一道典型的动态规划算法<br><img src="https://i.loli.net/2019/10/03/akwbvhJpWDguq7m.png" alt="屏幕快照 2019-10-03 上午10.46.08.png"></li>
<li>上述代码关键点是对特殊的n要做处理返回，即处理好n的边界。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/">官方解法</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(12)-买卖股票的最佳时机</title>
    <url>/post/cdee2405.html</url>
    <content><![CDATA[<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/10/06/dDRaxEVQmzhTjfr.png" alt="屏幕快照 2019-10-06 下午4.19.27.png"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxProfit1(int[] prices) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    int minPrice = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; prices.length; i++)&#123;</span><br><span class="line">        if (prices[i] &lt; minPrice)&#123;</span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">        &#125;else if (prices[i] - minPrice &gt; result)&#123;</span><br><span class="line">            result = prices[i] - minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述算法耗时1ms。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(13)-最大子序和</title>
    <url>/post/e8708265.html</url>
    <content><![CDATA[<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><p>给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<span id="more"></span>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    int result = nums[0];</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int item : nums)&#123;</span><br><span class="line">        if (sum + item  &gt; item)&#123;</span><br><span class="line">            sum += item;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sum = item;</span><br><span class="line">        &#125;</span><br><span class="line">        result = Math.max(result, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/hua-jie-suan-fa-53-zui-da-zi-xu-he-by-guanpengchn/">题解</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(14)-区域和检索</title>
    <url>/post/60c0216c.html</url>
    <content><![CDATA[<h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h2><p>给定一个整数数组nums，求出数组从索引i到j(i ≤ j)范围内元素的总和，包含i,j两点。示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">    private int[] mData;</span><br><span class="line"></span><br><span class="line">    public NumArray(int[] nums) &#123;</span><br><span class="line">        mData = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumRange(int i, int j) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int k = i; k &lt;= j; k++)&#123;</span><br><span class="line">            sum  += mData[k];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二：把求和转化为作差"><a href="#方法二：把求和转化为作差" class="headerlink" title="方法二：把求和转化为作差"></a>方法二：把求和转化为作差</h2><p>思路是先创造出来一个数组，该数组里第i个值表示i之前的原始数组nums之和，把问题转为新数组作差。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NumArray &#123;</span><br><span class="line">    private int[] mData;</span><br><span class="line"></span><br><span class="line">    public NumArray(int[] nums) &#123;</span><br><span class="line">        mData = new int[nums.length + 1];</span><br><span class="line">        for (int i = 0;  i &lt; nums.length; i++)&#123;</span><br><span class="line">            mData[i+1] = mData[i] + nums[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int sumRange(int i, int j) &#123;</span><br><span class="line">        return mData[j+1] - mData[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(15)-打家劫舍</title>
    <url>/post/db4a93d7.html</url>
    <content><![CDATA[<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/10/13/o3bBUsjzrpSmHhC.png" alt="屏幕快照 2019-10-13 下午4.29.16.png"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    if (nums.length == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp = new int[nums.length + 1];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line">    for (int i = 2; i &lt;= nums.length; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>要注意边界条件，考虑<code>nums</code>数组为空时返回0</li>
<li>要自己分析动态规划方程:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[n] = MAX( dp[n-1], dp[n-2] + num )</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/">画解算法：198. 打家劫舍</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(16)-粉刷房子</title>
    <url>/post/5339c6b6.html</url>
    <content><![CDATA[<h2 id="256-粉刷房子-会员题"><a href="#256-粉刷房子-会员题" class="headerlink" title="256. 粉刷房子(会员题)"></a><a href="https://leetcode-cn.com/problems/paint-house/">256. 粉刷房子(会员题)</a></h2><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/10/18/9kJySil4juvTFG6.png" alt="屏幕快照 2019-10-18 上午1.14.21.png"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int minCost(int[][] costs) &#123;</span><br><span class="line">    int n = costs.length;</span><br><span class="line">    int[][] dp = new int[n][3];</span><br><span class="line">    dp[0][0] = costs[0][0];</span><br><span class="line">    dp[0][1] = costs[0][1];</span><br><span class="line">    dp[0][2] = costs[0][2];</span><br><span class="line">    for (int i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; 3; j++)&#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-1][(j+1)%3], dp[i-1][(j+2)%3]) + costs[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.min(Math.min(dp[n-1][0], dp[n-1][1]), dp[n-1][2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们需要知道dp[i]和dp[i-1]之间的关系，设dp[i] 是粉刷到第i个房子要花费的最少成本。则dp[i]和第i个房子的状态有关，这样dp[i]有三种情况，分别刷对应的三种颜色。<br><img src="https://i.loli.net/2019/10/18/2wEQefWsCgyPjMq.png" alt="屏幕快照 2019-10-18 上午1.18.56.png"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>一定要处理输入数组为空的情况返回0；</li>
<li>带不同状态的动态规划</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/paint-house/solution/javafen-qing-kuang-de-dong-tai-gui-hua-by-sperger1/">https://leetcode-cn.com/problems/paint-house/solution/javafen-qing-kuang-de-dong-tai-gui-hua-by-sperger1/</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(17)-栅栏涂色</title>
    <url>/post/2553772c.html</url>
    <content><![CDATA[<h2 id="276-栅栏涂色"><a href="#276-栅栏涂色" class="headerlink" title="276. 栅栏涂色"></a><a href="https://leetcode-cn.com/problems/paint-fence/">276. 栅栏涂色</a></h2><p>有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，每个栅栏柱可以用其中一种颜色进行上色。你需要给所有栅栏柱上色，并且保证其中相邻的栅栏柱 最多连续两个 颜色相同。然后，返回所有有效涂色的方案数。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2019/10/20/X8boVa7kIuTM3Zs.png" alt="屏幕快照 2019-10-20 下午12.38.43.png"></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param n个栅栏</span><br><span class="line"> * @param k种颜色</span><br><span class="line"> * @return 多少种喷法</span><br><span class="line"> */</span><br><span class="line">public int numWays(int n, int k) &#123;</span><br><span class="line">    if (n == 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;else if (n == 1)&#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;else if (n == 2)&#123;</span><br><span class="line">        return k * k;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] dp = new int[n+1];</span><br><span class="line">    dp[0] = 0;</span><br><span class="line">    dp[1] = k;</span><br><span class="line">    dp[2] = k * k;</span><br><span class="line">    for (int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-1] * (k-1) + dp[i-2] * (k-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>需要针对n做一些特殊化处理，当n等于1只有一个栅栏时必然有k种涂法；</li>
<li>当n等于2时也就是有两个栅栏，共有k * k种涂法</li>
<li>当n大于等于3时通过动态规划实现，假设dp[i]等于有i个栅栏时的涂法，那么我们找dp[i]和dp[i-1]及之前的关系，分两种情况考虑。一种是第i个栅栏和i-1个栅栏涂的颜色不同，那必然有dp[i-1]*(k-1)种涂法。第二种情况，第i个栅栏和i-1个栅栏涂的颜色相同，那意味着i-1个栅栏和i-2个栅栏涂的颜色不同(因为最多只能有两个连续栅栏颜色相同)，也即:dp[i-2] * (k-1)，动态规划方程如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i] = dp[i-1] * (k-1) + dp[i-2] * (k-1)</span><br></pre></td></tr></table></figure></li>
<li><strong>总之一句话：动态规划先梳理边界条件，再找动态规划方程！！！</strong></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(2)-反转字符串</title>
    <url>/post/c101f8b.html</url>
    <content><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组<code>char[]</code>的形式给出。</p>
<span id="more"></span>

<h2 id="题解-折半遍历"><a href="#题解-折半遍历" class="headerlink" title="题解(折半遍历)"></a>题解(折半遍历)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void reverseString(char[] s) &#123;</span><br><span class="line">    int length = s.length;</span><br><span class="line">    for (int i = 0, j = length -1; i &lt;= j; i++, j--) &#123;</span><br><span class="line">        char temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(3)-字符串的编码与解码</title>
    <url>/post/82cdd3db.html</url>
    <content><![CDATA[<h2 id="271-字符串的编码与解码"><a href="#271-字符串的编码与解码" class="headerlink" title="271.字符串的编码与解码"></a><a href="https://leetcode-cn.com/problems/encode-and-decode-strings/">271.字符串的编码与解码</a></h2><p>设计一个算法，可以将一个 字符串列表 编码成为一个 字符串。这个编码后的字符串是可以通过网络进行高效传送的，并且可以在接收端被解码回原来的字符串列表。</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>猛一看题目很简单以为简单的拼接起来，中间加个分隔符就行了，但是输入字符串本身可能就是分隔符。所以必须还要加上长度信息，我们的加码方法是长度+”/“+字符串，比如对于”a”,”ab”,”abc”，我们就变成”1/a2/ab3/abc”，那么我们解码的时候就有规律可寻，先寻找”/“，然后之前的就是要取出的字符个数，从“/“后取出相应个数即可，以此类推直至没有”/“了。编码方法是这样，具体解码又以下三种思路。</p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>用一个索引<code>i</code>来标记从哪一位开始搜索分隔符，搜索到之后截出来前面的长度信息，根据长度信息再截出来对应字符串。之后把<code>i</code>往后移，重新开始搜索分隔符。代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Codec1 &#123;</span><br><span class="line">    // Encodes a list of strings to a single string.</span><br><span class="line">    public String encode(List&lt;String&gt; strs) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String item : strs) &#123;</span><br><span class="line">            int length = item.length();</span><br><span class="line">            sb.append(length).append(&quot;/&quot;).append(item);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Decodes a single string to a list of strings.</span><br><span class="line">    public List&lt;String&gt; decode(String s) &#123;</span><br><span class="line">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i &lt; s.length()) &#123;</span><br><span class="line">            int pos = s.indexOf(&#x27;/&#x27;, i);</span><br><span class="line">            int itemSize = Integer.parseInt(s.substring(i, pos));</span><br><span class="line">            int start = pos + 1;</span><br><span class="line">            int end = pos + itemSize + 1;</span><br><span class="line">            if (end &lt;= s.length()) &#123;</span><br><span class="line">                String item = s.substring(start, end);</span><br><span class="line">                result.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">            i = end;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>和解法1类似，区别在于我们每次可以从原始输入<code>s</code>里把对应<code>item</code>截出来后重新赋值，之后从裁剪后的<code>s</code>继续遍历，直到<code>s</code>为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Codec2 &#123;</span><br><span class="line">    public String encode(List&lt;String&gt; strs) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String item : strs) &#123;</span><br><span class="line">            sb.append(item.length()).append(&quot;/&quot;).append(item);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; decode(String s) &#123;</span><br><span class="line">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        while (!s.isEmpty()) &#123;</span><br><span class="line">            int pos = s.indexOf(&quot;/&quot;);</span><br><span class="line">            int itemSize = Integer.parseInt(s.substring(0, pos));</span><br><span class="line">            result.add(s.substring(pos + 1, pos + itemSize + 1));</span><br><span class="line">            s = s.substring(pos + itemSize + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p>我们可以编码的时候通过Java里的换行符<code>\n</code>进行分割，读入时借助<code>BufferReader</code>逐行读取就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Codec &#123;</span><br><span class="line">    public String encode(List&lt;String&gt; strs) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (String item : strs) &#123;</span><br><span class="line">            sb.append(item).append(&#x27;\n&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; decode(String s) &#123;</span><br><span class="line">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        BufferedReader br = new BufferedReader(new StringReader(s));</span><br><span class="line">        String temp = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            while ((temp = br.readLine()) != null) &#123;</span><br><span class="line">                result.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h2><table>
<thead>
<tr>
<th>解法</th>
<th>耗时</th>
<th>内存</th>
</tr>
</thead>
<tbody><tr>
<td>解法1</td>
<td>7ms</td>
<td>39.3MB</td>
</tr>
<tr>
<td>解法2</td>
<td>15ms</td>
<td>39.8MB</td>
</tr>
<tr>
<td>解法3</td>
<td>23ms</td>
<td>38.7MB</td>
</tr>
</tbody></table>
<p>以下为leetcode执行结果:<br><img src="https://i.loli.net/2019/09/22/v5RXUIhozKsZuiH.png" alt="WX20190922-104129@2x.png"></p>
<h2 id="String基础操作"><a href="#String基础操作" class="headerlink" title="String基础操作"></a><a href="https://www.runoob.com/java/java-string.html">String基础操作</a></h2><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a><code>indexOf</code></h3><p>从左往右查找第一次出现x的索引，如果不出现则返回-1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the index within this string of the first occurrence of the</span><br><span class="line"> * specified substring.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span><br><span class="line"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned.</span><br><span class="line"> *</span><br><span class="line"> * @param   str   the substring to search for.</span><br><span class="line"> * @return  the index of the first occurrence of the specified substring,</span><br><span class="line"> *          or &#123;@code -1&#125; if there is no such occurrence.</span><br><span class="line"> */</span><br><span class="line">public int indexOf(String str) &#123;</span><br><span class="line">    return indexOf(str, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中indexOf(str, 0)原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the index within this string of the first occurrence of the</span><br><span class="line"> * specified substring, starting at the specified index.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which:</span><br><span class="line"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span><br><span class="line"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line"> * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned.</span><br><span class="line"> *</span><br><span class="line"> * @param   str         the substring to search for.</span><br><span class="line"> * @param   fromIndex   the index from which to start the search.</span><br><span class="line"> * @return  the index of the first occurrence of the specified substring,</span><br><span class="line"> *          starting at the specified index,</span><br><span class="line"> *          or &#123;@code -1&#125; if there is no such occurrence.</span><br><span class="line"> */</span><br><span class="line">public int indexOf(String str, int fromIndex) &#123;</span><br><span class="line">    return indexOf(value, 0, value.length,</span><br><span class="line">            str.value, 0, str.value.length, fromIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fromIndex</code>表示开始搜索的地方，是算在数的。</p>
<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a><code>lastIndexOf</code></h3><p>从最后面开始找第一次出现x的索引，索引位置还是从正向开始计算的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the index within this string of the last occurrence of the</span><br><span class="line">     * specified substring.  The last occurrence of the empty string &quot;&quot;</span><br><span class="line">     * is considered to occur at the index value &#123;@code this.length()&#125;.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which:</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span><br><span class="line">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned.</span><br><span class="line">     *</span><br><span class="line">     * @param   str   the substring to search for.</span><br><span class="line">     * @return  the index of the last occurrence of the specified substring,</span><br><span class="line">     *          or &#123;@code -1&#125; if there is no such occurrence.</span><br><span class="line">     */</span><br><span class="line">    public int lastIndexOf(String str) &#123;</span><br><span class="line">        return lastIndexOf(str, value.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the index within this string of the last occurrence of the</span><br><span class="line">     * specified substring, searching backward starting at the specified index.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which:</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * &lt;i&gt;k&lt;/i&gt; &#123;@code &lt;=&#125; fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;)</span><br><span class="line">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned.</span><br><span class="line">     *</span><br><span class="line">     * @param   str         the substring to search for.</span><br><span class="line">     * @param   fromIndex   the index to start the search from.</span><br><span class="line">     * @return  the index of the last occurrence of the specified substring,</span><br><span class="line">     *          searching backward from the specified index,</span><br><span class="line">     *          or &#123;@code -1&#125; if there is no such occurrence.</span><br><span class="line">     */</span><br><span class="line">    public int lastIndexOf(String str, int fromIndex) &#123;</span><br><span class="line">        return lastIndexOf(value, 0, value.length,</span><br><span class="line">                str.value, 0, str.value.length, fromIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>indexOf和lastIndexOf里第二个位置参数是参与搜索的。</p>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a><code>substring</code></h3><p><code>substring(int beginIndex, int endIndex)</code>截取的是从beginIndex开始到endIndex-1的字符串，截出来的长度为endIndex-beginIndex。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns a string that is a substring of this string. The</span><br><span class="line">     * substring begins at the specified &#123;@code beginIndex&#125; and</span><br><span class="line">     * extends to the character at index &#123;@code endIndex - 1&#125;.</span><br><span class="line">     * Thus the length of the substring is &#123;@code endIndex-beginIndex&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Examples:</span><br><span class="line">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="line">     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="line">     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="line">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param      beginIndex   the beginning index, inclusive.</span><br><span class="line">     * @param      endIndex     the ending index, exclusive.</span><br><span class="line">     * @return     the specified substring.</span><br><span class="line">     * @exception  IndexOutOfBoundsException  if the</span><br><span class="line">     *             &#123;@code beginIndex&#125; is negative, or</span><br><span class="line">     *             &#123;@code endIndex&#125; is larger than the length of</span><br><span class="line">     *             this &#123;@code String&#125; object, or</span><br><span class="line">     *             &#123;@code beginIndex&#125; is larger than</span><br><span class="line">     *             &#123;@code endIndex&#125;.</span><br><span class="line">     */</span><br><span class="line">    public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (endIndex &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen = endIndex - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</span><br><span class="line">                : new String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/grandyang/leetcode/issues/271">https://github.com/grandyang/leetcode/issues/271</a></li>
<li><a href="https://blog.csdn.net/weixin_41141219/article/details/80611858">JAVA中String字符串的各种基本操作</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(4)-反转字符串中的元音字母</title>
    <url>/post/795f0ef9.html</url>
    <content><![CDATA[<h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题里暗含几个陷阱:</p>
<ol>
<li><p>什么是元音字母？以下几个都是，注意含大写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char[] dicts = new char[]&#123;&#x27;a&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;O&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;U&#x27;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java里<code>String</code>是不可变的，修改的话需要转成<code>char[] xx = s.toCharArray</code>；</p>
</li>
<li><p>如果输入字符串长度为1直接返回即可，不需要计算；</p>
</li>
<li><p>正确抽象模型(<strong>快排思想</strong>)：示例里只替换了一组元音字母，但是隐含的意思是要替换所有的元音。用两个索引分别标记最左边和最右边，从左边找到第一个元音停下来，然后从右边再找到第一个元音停下来，如果两个索引没有越界则交换。之后左边索引+1右边索引-1即可，直到左右索引越界结束循环。</p>
</li>
</ol>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这是我自己写的答案，有点拉杂：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public String reverseVowels(String s) &#123;</span><br><span class="line">        char[] dicts = new char[] &#123;&#x27;a&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;O&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;U&#x27;&#125;;</span><br><span class="line">        List&lt;Character&gt; yuanyinList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char temp : dicts)&#123;</span><br><span class="line">            yuanyinList.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        char[] newDicts = s.toCharArray();</span><br><span class="line">        if (s.length() == 1)&#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = s.length() -1;</span><br><span class="line">        while ( i&lt;j )&#123;</span><br><span class="line">            char left = newDicts[i];</span><br><span class="line">            char right = newDicts[j];</span><br><span class="line">        </span><br><span class="line">            // 两边都是元音字母</span><br><span class="line">            if (yuanyinList.contains(left) &amp;&amp; yuanyinList.contains(right))&#123;</span><br><span class="line">                if (left != right) &#123;</span><br><span class="line">                    newDicts[i] = right;</span><br><span class="line">                    newDicts[j] = left;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!yuanyinList.contains(left))&#123;</span><br><span class="line">                i++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!yuanyinList.contains(right))&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(newDicts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.company;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public String reverseVowels(String s) &#123;</span><br><span class="line">        char[] dicts = new char[]&#123;&#x27;a&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;O&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;U&#x27;&#125;;</span><br><span class="line">        List&lt;Character&gt; yuanyinList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char temp : dicts) &#123;</span><br><span class="line">            yuanyinList.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        char[] newDicts = s.toCharArray();</span><br><span class="line">        if (s.length() == 1) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0, j = s.length() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            // 找到最左边的字母然后停下来</span><br><span class="line">            while (i &lt; j &amp;&amp; !yuanyinList.contains(newDicts[i])) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            // 找到最右边的字母然后停下来</span><br><span class="line">            while (i &lt; j &amp;&amp; !yuanyinList.contains(newDicts[j])) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            // 两边都是元音字母</span><br><span class="line">            if (i &lt; j) &#123;</span><br><span class="line">                char temp = newDicts[i];</span><br><span class="line">                newDicts[i] = newDicts[j];</span><br><span class="line">                newDicts[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(newDicts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>考虑到大小写元音问题，可以通过<code>Character.toLowerCase(&#39;A&#39;)</code>把<code>char</code>都转小写再比较。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean isVowel(char c) &#123;</span><br><span class="line">    char lowerC = Character.toLowerCase(c);</span><br><span class="line">    return lowerC == &#x27;a&#x27; || lowerC == &#x27;e&#x27; || lowerC == &#x27;i&#x27; || lowerC == &#x27;o&#x27; || lowerC == &#x27;u&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(5)-删除排序数组中的重复项</title>
    <url>/post/864ad132.html</url>
    <content><![CDATA[<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<span id="more"></span>
<h2 id="解法1（我的解法）"><a href="#解法1（我的解法）" class="headerlink" title="解法1（我的解法）"></a>解法1（我的解法）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates2(int[] nums) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int j = 1; j&lt;nums.length; j++)&#123;</span><br><span class="line">       while (j&lt;nums.length &amp;&amp; nums[j] == nums[i]) j++;</span><br><span class="line">       if (j &lt; nums.length) &#123;</span><br><span class="line">           i++;</span><br><span class="line">           nums[i] = nums[j];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进到<code>for</code>循环后来个<code>while</code>循环找到第一个不等于前一个变量的索引出循环然后赋值。需要注意的是while循环时必须保证索引不越界。后来发现这个while可以和for合并，请看下边管法答案。</p>
<h2 id="解法2（官方）"><a href="#解法2（官方）" class="headerlink" title="解法2（官方）"></a>解法2（官方）</h2><p>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加j以跳过重复项。当我们遇到 nums[j]!= nums[i]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int j = 1; j&lt;nums.length; j++)&#123;</span><br><span class="line">        if (nums[j] != nums[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(6)-移除元素</title>
    <url>/post/26850355.html</url>
    <content><![CDATA[<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h2><p>给定一个数组<code>nums</code>和一个值<code>val</code>，你需要原地移除所有数值等于<code>val</code>的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (int j = 0; j&lt;nums.length; j++)&#123;</span><br><span class="line">        if (nums[j] != val)&#123;</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为题目说要原地移除，那一定是原地遍历一遍直接赋值。采用快慢指针方式，慢指针指向修正后数组索引，快指针进行遍历。这个题关键点是要找到如果遍历值和val相等则继续遍历，直到不相等进行赋值操作。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(8)-最接近的三数之和</title>
    <url>/post/f209e897.html</url>
    <content><![CDATA[<h2 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">     int result = nums[0] + nums[1] + nums[2];</span><br><span class="line">     int diff = Integer.MAX_VALUE;</span><br><span class="line">     for (int i = 0; i &lt; nums.length-2; i++)&#123;</span><br><span class="line">         int left = i + 1;</span><br><span class="line">         int right = nums.length - 1;</span><br><span class="line">         while (left &lt; right)&#123;</span><br><span class="line">             int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">             if (sum &lt; target)&#123;</span><br><span class="line">                 left++;</span><br><span class="line">             &#125;else if(sum &gt; target)&#123;</span><br><span class="line">                 right--;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 result = target;</span><br><span class="line">                 return result;</span><br><span class="line">             &#125;</span><br><span class="line">             if (Math.abs(sum -target) &lt; diff)&#123;</span><br><span class="line">                 diff = Math.abs(sum -target);</span><br><span class="line">                 result = sum;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br></pre></td></tr></table></figure>
<p>上面是最基本最正宗的解法，耗时11ms左右。</p>
<h2 id="优化后解法2"><a href="#优化后解法2" class="headerlink" title="优化后解法2"></a>优化后解法2</h2><p>当有相同数字时，如第i个等于第i-1个，进行剪枝操作跳过当前的i。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int threeSumClosest2(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int result = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int diff = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; //剪枝去重</span><br><span class="line"></span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else if (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result = target;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">                if (Math.abs(sum - target) &lt; diff) &#123;</span><br><span class="line">                    diff = Math.abs(sum - target);</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>经过优化后时间缩短到5ms。</p>
<h2 id="优化后解法3"><a href="#优化后解法3" class="headerlink" title="优化后解法3"></a>优化后解法3</h2><p>在上面2的基础上还可以进一步优化，排序后的数组对给定的索引i，在[left, right]区间内，最大值 rangeMax = nums[i] + nums[right] + nums[right - 1]，最小值为 rangeMin = nums[i] + nums[left] + nums[left + 1]。如果最小值都比target大，那left右边的数一定比target大也就没有必要比下去了。因此只需判断rangeMin和target之间的diff是否最小，如果小的话更新diff和result。同理，针对区间内的最大值rangeMax如果它都比target小的话，那right右边的肯定都比target小，也没有比的必要了。只需要判断rangeMax和target之间的diff关系就行了。<br><strong>总之：rangeMin和rangeMax是两种极端情况，让程序不再做无谓的循环比较。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int result = nums[0] + nums[1] + nums[2];</span><br><span class="line">        int diff = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">            int rangeMin = nums[i] + nums[left] + nums[left + 1];</span><br><span class="line">            int rangeMax = nums[i] + nums[right] + nums[right - 1];</span><br><span class="line"></span><br><span class="line">            if (rangeMin &gt; target) &#123;</span><br><span class="line">                if (Math.abs(rangeMin - target) &lt; diff) &#123;</span><br><span class="line">                    diff = Math.abs(rangeMin - target);</span><br><span class="line">                    result = rangeMin;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else if (rangeMax &lt; target) &#123;</span><br><span class="line">                if (Math.abs(rangeMax - target) &lt; diff) &#123;</span><br><span class="line">                    diff = Math.abs(rangeMax - target);</span><br><span class="line">                    result = rangeMax;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else if (sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result = target;</span><br><span class="line">                    return result;</span><br><span class="line">                &#125;</span><br><span class="line">                if (Math.abs(sum - target) &lt; diff) &#123;</span><br><span class="line">                    diff = Math.abs(sum - target);</span><br><span class="line">                    result = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码执行时间缩短到2ms。</p>
<h2 id="三种解法时间对比"><a href="#三种解法时间对比" class="headerlink" title="三种解法时间对比"></a>三种解法时间对比</h2><p><img src="https://i.loli.net/2019/10/01/2bJIW4UZj3tPNEM.png" alt="屏幕快照 2019-10-01 下午7.53.35.png"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>一定要仔细读题，题目要求返回的是sum，和target最接近的求和，而不是diff；</li>
<li>进入循环后如果i和i-1值相同，一定要进行剪枝操作；</li>
<li>初始diff设成最大，之后不断修正成最小值；</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/3sum-closest/solution/shuang-zhi-zhen-dui-zhuang-python-dai-ma-java-dai-/">双指针对撞</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(9)-较小的三数之和</title>
    <url>/post/49a15473.html</url>
    <content><![CDATA[<h2 id="259-较小的三数之和-会员题"><a href="#259-较小的三数之和-会员题" class="headerlink" title="259. 较小的三数之和(会员题)"></a><a href="https://leetcode-cn.com/problems/3sum-smaller/">259. 较小的三数之和(会员题)</a></h2><p>给定一个长度为 n 的整数数组和一个目标值 target，寻找能够使条件 nums[i] + nums[j] + nums[k] &lt; target 成立的三元组  i, j, k 个数（0 &lt;= i &lt; j &lt; k &lt; n）。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,0,1,3], target = 2</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 因为一共有两个三元组满足累加和小于 2:</span><br><span class="line">     [-2,0,1]</span><br><span class="line">     [-2,0,3]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int threeSumSmaller(int[] nums, int target) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line"></span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &lt; target) &#123;</span><br><span class="line">                    result += right - left;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h3 id="读题"><a href="#读题" class="headerlink" title="读题"></a>读题</h3><p>注意题目要求是返回的满足要求的i、j、k三元组个数，这意味着如果有两个数字是重复的，虽然数值一样但是索引位置不同，也认为是不同的结果。所以进到for循环后，不能有<code>nums[i] == nums[i-1]</code>的剪枝操作，如果剪枝了直接答案会不对。</p>
<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>这道题的关键在<code>result += right - left;</code>，即针对某个left，如果找到一个right满足要求小于了target，则right右边的数字一定是小于target的，因此直接得到个数<code>right - left</code>，然后让left移位。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>刷算法(7)-三数之和</title>
    <url>/post/3ad49f62.html</url>
    <content><![CDATA[<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p><img src="https://i.loli.net/2019/10/01/MuzHD6gpFPte3Sd.png" alt="屏幕快照 2019-10-01 下午3.51.47.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        if (nums[i] &gt; 0) break;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line">        int left = i+1, right = nums.length - 1;</span><br><span class="line">        while (left &lt; right)&#123;</span><br><span class="line">            int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            if ( sum == 0)&#123;</span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--;</span><br><span class="line">                while (left &lt; right &amp;&amp; nums[left] == nums[left+1]) left++;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else if (sum &gt; 0)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol>
<li>整体思路是先对数组进行排序，然后对有序数组依次查找，用最左、最右两个指针索引进行遍历;</li>
<li>因为数组是递增的，一旦<code>num[i] &gt; 0</code>则对索引i就不需要再找了需要结束整个流程(因为i右边的数都比它大)；</li>
<li>如果遍历到i，但是num[i]等于num[i-1]，则忽略这个i，从i的下一个开始找，通过for循环控制；</li>
<li>针对i，定义left和right，在left和right区间去找，计算三者sum；</li>
<li>如果<code>sum = 0</code>，则放到结果里，同时对left和right，判断是否有重复的，如果有重复的就往前/往后移位。这里有两个注意事项：</li>
</ol>
<ul>
<li>1)注意是通过left和left+1比的，意味着出while后，left指的位置仍然是当下参与计算sum的那个索引，出循环后left和right要进行递增、递减操作，这一切都归功于数组是递增有序的；</li>
<li>2)注意while循环的条件一定有<code>left &lt; right</code>，这一点非常关键；</li>
</ul>
<ol start="6">
<li>如果<code>sum &gt; 0</code>意味着值太大了，需要小点，那就把right递减下；</li>
<li>如果<code>sum &lt; 0</code>意味着太小了，需要更大，那就把left递增加大下这个值，因为right是从最右边来的，已经是最大的了；</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/">画解算法：15. 三数之和</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>npm安装依赖至指定版本的方法</title>
    <url>/post/f007732d.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍npm安装依赖至指定版本的方法,依赖的版本可以在<a href="https://npm.taobao.org/">淘宝镜像</a>或<a href="https://www.npmjs.com/">官方</a>查询到.</p>
<span id="more"></span>
<h2 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>先在package.json里修改好指定版本号，然后输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update webpack</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update webpack@4.7.0</span><br></pre></td></tr></table></figure>
<p>会把webpack更新至指定版本，但是不会写到package.json文件里，如果需要写到package.json里执行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update webpack@4.7.0 --save</span><br></pre></td></tr></table></figure>
<p>其中<code>--save</code>等于<code>-S</code>.</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update webpack@latest -S</span><br></pre></td></tr></table></figure>

<h2 id="save和-save-dev区别"><a href="#save和-save-dev区别" class="headerlink" title="--save和--save-dev区别"></a><code>--save</code>和<code>--save-dev</code>区别</h2><p>一句话:<code>--save-dev</code>是你开发时依赖的东西，<code>--save</code>是发布后还依赖的东西.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://segmentfault.com/q/1010000009049039?_ea=1823977">https://segmentfault.com/q/1010000009049039?_ea=1823977</a></li>
<li><a href="https://segmentfault.com/q/1010000005163089">https://segmentfault.com/q/1010000005163089</a></li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>npm设置和取消代理的方法</title>
    <url>/post/8f460f7b.html</url>
    <content><![CDATA[<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set proxy=http://127.0.0.1:8087</span><br><span class="line">npm config set registry=http://registry.npmjs.org</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><p>经过上面设置使用了http开头的源，因此不需要设https_proxy了，否则还要增加一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set https-proxy http://server:port</span><br></pre></td></tr></table></figure>
<h2 id="代理用户名和密码"><a href="#代理用户名和密码" class="headerlink" title="代理用户名和密码"></a>代理用户名和密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set proxy http://username:password@server:port</span><br><span class="line">npm confit set https-proxy http://username:password@server:port</span><br></pre></td></tr></table></figure>
<h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure>
<h2 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h2><p>请参考<a href="https://segmentfault.com/a/1190000002589144">https://segmentfault.com/a/1190000002589144</a></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python批量push多个仓至github</title>
    <url>/post/6d48edea.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文记录使用Python批量从bare类型的git仓库上push到bitbucket.</p>
<span id="more"></span>
<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><p>废话不说，先来看代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018/5/20 下午12:50</span><br><span class="line"># @Site    : </span><br><span class="line"># @File    : main.py</span><br><span class="line"># @Software: PyCharm Community Edition</span><br><span class="line">import os</span><br><span class="line">def main():</span><br><span class="line">    DIR = &#x27;/Users/yanzi/work/git/xxx-android-framework&#x27;</span><br><span class="line">    if not os.path.exists(DIR):</span><br><span class="line">        print(&#x27;error: %s not exist&#x27; % DIR)</span><br><span class="line">        return</span><br><span class="line">    if os.path.isfile(DIR):</span><br><span class="line">        print(&#x27;error: %s is not dir&#x27; % DIR)</span><br><span class="line">        return</span><br><span class="line">    dirs = os.listdir(DIR)</span><br><span class="line">    PATH = []</span><br><span class="line">    REPO = []</span><br><span class="line">    i = 0</span><br><span class="line">    for git in dirs:</span><br><span class="line">        if str(git).endswith(&#x27;.git&#x27;):</span><br><span class="line">            # if i == 3:</span><br><span class="line">            #     break</span><br><span class="line">            PATH = getPath(DIR, git)</span><br><span class="line">            pushRepo(PATH, git)</span><br><span class="line">            i += 1</span><br><span class="line"></span><br><span class="line">    #遍历文件夹DIR</span><br><span class="line">    # for (root, dirs, files) in os.walk(DIR):</span><br><span class="line">    #     if root == DIR:</span><br><span class="line">    #         print(dirs)</span><br><span class="line">    #         break</span><br><span class="line"></span><br><span class="line">def getPath(dir, git):</span><br><span class="line">    return dir + &#x27;/&#x27; + git</span><br><span class="line"></span><br><span class="line">def getRepo(git):</span><br><span class="line">    return git[:-4]</span><br><span class="line"></span><br><span class="line">def pushRepo(path, git):</span><br><span class="line">    os.chdir(path)</span><br><span class="line">    pushCmd = &#x27;git push --mirror git@bitbucket.org:xxx/&#x27; + git</span><br><span class="line">    print(pushCmd)</span><br><span class="line">    os.system(pushCmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol>
<li><code>git push --mirror xxx</code>可以push仓下的所有分支和tag至origin上。</li>
<li>通过python进入不同的工作目录应通过<code>os.chdir(path)</code>而不是<code>os.system(&#39;cd /Users/xxx&#39;)</code>.</li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实现定时重启</title>
    <url>/post/1b7970e0.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍在CentOS和Debian上实现定时重启的功能.</p>
<span id="more"></span>
<h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="检查crond服务是否开机自启"><a href="#检查crond服务是否开机自启" class="headerlink" title="检查crond服务是否开机自启"></a>检查crond服务是否开机自启</h3><p>CentOS上运行<code>systemctl is-enabled crond.service</code>，如果是disabled的话运行<code>systemctl enable crond.service</code>开启。</p>
<p><strong>注意:如果crond服务不能开机自启的话，则第一次重启后，以后定时任务就没法持续了。</strong></p>
<h3 id="开启crond服务"><a href="#开启crond服务" class="headerlink" title="开启crond服务"></a>开启crond服务</h3><p>运行:<code>service start crond</code>开启服务，<code>service crond status</code>查看状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active: active (running) since Sun 2017-09-24 09:26:23 EDT; 3h 32min ago</span><br></pre></td></tr></table></figure>
<p>包含以上输出表示已经开启crond服务.</p>
<h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h3><p>创建:<code>crontable -e</code>,之后输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 4 * * * /sbin/reboot</span><br></pre></td></tr></table></figure>
<p>表示每天早上4:0分重启.</p>
<h2 id="debian10"><a href="#debian10" class="headerlink" title="debian10"></a>debian10</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install cron</span><br><span class="line">crontab  -e</span><br><span class="line">0 4 * * * /sbin/reboot</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动/etc/init.d/cron start</span><br><span class="line"></span><br><span class="line">关闭/etc/init.d/cron stop</span><br><span class="line"></span><br><span class="line">重启/etc/init.d/cron restart</span><br></pre></td></tr></table></figure>

<h3 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab  -l </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>综合</category>
      </categories>
  </entry>
  <entry>
    <title>Trojan科学新姿势</title>
    <url>/post/c2a70526.html</url>
    <content><![CDATA[<p>本文介绍Trojan科学上网一键脚本配置。</p>
<span id="more"></span>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>我选择的是<a href="https://console.cloud.google.com/compute/instances">Google VPS</a>，创建一个台湾或香港实例，选择debian9或10，记录外网IP。</p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><ol>
<li>购买域名可以选择<a href="www.namesilo.com">namesilo</a>或<a href="www.namecheap.com">namecheap</a>;</li>
<li>在域名的dns解析设置里新增一个<strong>A</strong>解析记录，hostname填写任意字符串，如a或0，则后面配置VPS绑定域名时就是<code>a.xxx.com</code>或<code>0.xxx.com</code>，IP填写上面的外网IP, TTL填写3603。注意这里的<code>A</code>解析后面用来配IP地址,表示访问某个域名指向某IP。</li>
<li>等待域名解析生效可以通过ping域名方式，一般需要10分钟。</li>
</ol>
<p>备注：如果是<code>namesilo</code>可以直接访问<a href="https://www.namesilo.com/account_domain_manage_dns.php">https://www.namesilo.com/account_domain_manage_dns.php</a>修改DNS解析，万网访问<a href="https://dns.console.aliyun.com/#/dns/domainList">https://dns.console.aliyun.com/#/dns/domainList</a>。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="SSH登陆"><a href="#SSH登陆" class="headerlink" title="SSH登陆"></a>SSH登陆</h3><p>首先进行SSH登陆，如果是Google VPS需要进行以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>修改配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure>
<p>然后记得通过<code>passwd root</code>设置root登陆密码。</p>
<p>然后重启SSH:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>


<h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><ol>
<li>安装准备软件:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update -y &amp;&amp; apt-get install curl -y    ##Ubuntu/Debian 系统安装 Curl 方法</span><br><span class="line">apt-get install xz-utils   #Debian/Ubuntu 安装 XZ 压缩工具命令</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载一键安装脚本<br>通过<code>wget https://github.com/V2RaySSR/Trojan/raw/master/Trojan.sh</code>或直接</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://github.com/V2RaySSR/Trojan/raw/master/Trojan.sh)</span><br></pre></td></tr></table></figure>

<p>之后先安装BBR Plus内核，然后开启BBRPlus加速，中间会选择重启VPS。然后安装Trajon，安装时输入对应域名即可。</p>
<p><strong>3. 安装完毕后查看密码及重启命令</strong></p>
<p>修改密码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/src/trojan/server.conf</span><br></pre></td></tr></table></figure>

<p>重启:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart trojan</span><br></pre></td></tr></table></figure>

<p>查看状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service trojan status</span><br></pre></td></tr></table></figure>

<h3 id="定时重启"><a href="#定时重启" class="headerlink" title="定时重启"></a>定时重启</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install cron</span><br><span class="line">crontab  -e</span><br><span class="line">输入：0 4 * * * /sbin/reboot</span><br><span class="line"></span><br><span class="line">启动：/etc/init.d/cron start</span><br><span class="line"></span><br><span class="line">关闭：/etc/init.d/cron stop</span><br><span class="line"></span><br><span class="line">重启『/etc/init.d/cron restart</span><br><span class="line"></span><br><span class="line">查看列表：crontab  -l </span><br></pre></td></tr></table></figure>

<h2 id="端侧"><a href="#端侧" class="headerlink" title="端侧"></a>端侧</h2><h3 id="Windows、Mac、Linux"><a href="#Windows、Mac、Linux" class="headerlink" title="Windows、Mac、Linux"></a>Windows、Mac、Linux</h3><p>Windows上直接下载安装完毕后生成的压缩包，点击启动bat即可。也可以到<a href="https://github.com/trojan-gfw/trojan/releases">官网</a>下载。修改<code>config.json</code>即可。<br>注意：非windows的客户端使用时，最好是从安装完成后的下载链接里，把完整证书<strong>fullchain.cer</strong>和配置<strong>config.json</strong>下载下来，然后copy到对应端的脚手架工程里。</p>
<h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p><a href="https://github.com/JimLee1996/TrojanX/releases">TrojanX</a></p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p><a href="https://github.com/trojan-gfw/igniter/releases">igniter</a></p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="问题1：ssl-handshake-timeout"><a href="#问题1：ssl-handshake-timeout" class="headerlink" title="问题1：ssl handshake timeout"></a>问题1：ssl handshake timeout</h3><p>优先通过<a href="https://tool.chinaz.com/port">https://tool.chinaz.com/port</a>检查<strong>443</strong>端口是否被封，如果被封则修改Trojan的端口为其他端口，server端编辑<code>/usr/src/trojan/server.conf</code>里的端口即可，然后客户端使用相同的端口即可。</p>
<h3 id="问题2：It-is-recommended-to-install-socat-first"><a href="#问题2：It-is-recommended-to-install-socat-first" class="headerlink" title="问题2：It is recommended to install socat first"></a>问题2：It is recommended to install socat first</h3><p>如果遇到证书没有申请成功：<code>一键安装的时候显示 https证书没有申请成果，本次安装失败</code>观察是否存在以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It is recommended to install socat first</span><br></pre></td></tr></table></figure>

<p>如果存在的话执行下面命令解决:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install curl -y &amp;&amp; apt-get install cron -y &amp;&amp; apt-get install socat -y</span><br></pre></td></tr></table></figure>

<h3 id="问题3：Please-update-your-account-with-an-email-address-first"><a href="#问题3：Please-update-your-account-with-an-email-address-first" class="headerlink" title="问题3：Please update your account with an email address first"></a>问题3：Please update your account with an email address first</h3><p>解决替换自己的邮箱:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.acme.sh/acme.sh  --uninstall</span><br><span class="line"></span><br><span class="line">curl  https://get.acme.sh | sh -s email=xxxx@xx.com</span><br></pre></td></tr></table></figure>

<h3 id="问题4：一直报Order-status-is-processing-lets-sleep-and-retry"><a href="#问题4：一直报Order-status-is-processing-lets-sleep-and-retry" class="headerlink" title="问题4：一直报Order status is processing, lets sleep and retry"></a>问题4：一直报<code>Order status is processing, lets sleep and retry</code></h3><p>如果在签发 ZeroSSL 证书时，不停的循环 Order status is processing, lets sleep and retry。可以选择将 CA 更换为 Let’s Encrypt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">acme.sh --set-default-ca --server letsencrypt</span><br></pre></td></tr></table></figure>

<h3 id="问题5：nginx启动错误"><a href="#问题5：nginx启动错误" class="headerlink" title="问题5：nginx启动错误:"></a>问题5：nginx启动错误:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx: [emerg] open() &quot;/etc/nginx/mime.types&quot; failed (2: No such file or directory) in /etc/nginx/nginx.conf:9</span><br></pre></td></tr></table></figure>

<p>解决<code>vim mime.types</code>内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">    text/html                             html htm shtml;</span><br><span class="line">    text/css                              css;</span><br><span class="line">    text/xml                              xml;</span><br><span class="line">    image/gif                             gif;</span><br><span class="line">    image/jpeg                            jpeg jpg;</span><br><span class="line">    application/javascript                js;</span><br><span class="line">    application/atom+xml                  atom;</span><br><span class="line">    application/rss+xml                   rss;</span><br><span class="line"></span><br><span class="line">    text/mathml                           mml;</span><br><span class="line">    text/plain                            txt;</span><br><span class="line">    text/vnd.sun.j2me.app-descriptor      jad;</span><br><span class="line">    text/vnd.wap.wml                      wml;</span><br><span class="line">    text/x-component                      htc;</span><br><span class="line"></span><br><span class="line">    image/png                             png;</span><br><span class="line">    image/tiff                            tif tiff;</span><br><span class="line">    image/vnd.wap.wbmp                    wbmp;</span><br><span class="line">    image/x-icon                          ico;</span><br><span class="line">    image/x-jng                           jng;</span><br><span class="line">    image/x-ms-bmp                        bmp;</span><br><span class="line">    image/svg+xml                         svg svgz;</span><br><span class="line">    image/webp                            webp;</span><br><span class="line"></span><br><span class="line">    application/font-woff                 woff;</span><br><span class="line">    application/java-archive              jar war ear;</span><br><span class="line">    application/json                      json;</span><br><span class="line">    application/mac-binhex40              hqx;</span><br><span class="line">    application/msword                    doc;</span><br><span class="line">    application/pdf                       pdf;</span><br><span class="line">    application/postscript                ps eps ai;</span><br><span class="line">    application/rtf                       rtf;</span><br><span class="line">    application/vnd.apple.mpegurl         m3u8;</span><br><span class="line">    application/vnd.ms-excel              xls;</span><br><span class="line">    application/vnd.ms-fontobject         eot;</span><br><span class="line">    application/vnd.ms-powerpoint         ppt;</span><br><span class="line">    application/vnd.wap.wmlc              wmlc;</span><br><span class="line">    application/vnd.google-earth.kml+xml  kml;</span><br><span class="line">    application/vnd.google-earth.kmz      kmz;</span><br><span class="line">    application/x-7z-compressed           7z;</span><br><span class="line">    application/x-cocoa                   cco;</span><br><span class="line">    application/x-java-archive-diff       jardiff;</span><br><span class="line">    application/x-java-jnlp-file          jnlp;</span><br><span class="line">    application/x-makeself                run;</span><br><span class="line">    application/x-perl                    pl pm;</span><br><span class="line">    application/x-pilot                   prc pdb;</span><br><span class="line">    application/x-rar-compressed          rar;</span><br><span class="line">    application/x-redhat-package-manager  rpm;</span><br><span class="line">    application/x-sea                     sea;</span><br><span class="line">    application/x-shockwave-flash         swf;</span><br><span class="line">    application/x-stuffit                 sit;</span><br><span class="line">    application/x-tcl                     tcl tk;</span><br><span class="line">    application/x-x509-ca-cert            der pem crt;</span><br><span class="line">    application/x-xpinstall               xpi;</span><br><span class="line">    application/xhtml+xml                 xhtml;</span><br><span class="line">    application/xspf+xml                  xspf;</span><br><span class="line">    application/zip                       zip;</span><br><span class="line"></span><br><span class="line">    application/octet-stream              bin exe dll;</span><br><span class="line">    application/octet-stream              deb;</span><br><span class="line">    application/octet-stream              dmg;</span><br><span class="line">    application/octet-stream              iso img;</span><br><span class="line">    application/octet-stream              msi msp msm;</span><br><span class="line"></span><br><span class="line">    application/vnd.openxmlformats-officedocument.wordprocessingml.document    docx;</span><br><span class="line">    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet          xlsx;</span><br><span class="line">    application/vnd.openxmlformats-officedocument.presentationml.presentation  pptx;</span><br><span class="line"></span><br><span class="line">    audio/midi                            mid midi kar;</span><br><span class="line">    audio/mpeg                            mp3;</span><br><span class="line">    audio/ogg                             ogg;</span><br><span class="line">    audio/x-m4a                           m4a;</span><br><span class="line">    audio/x-realaudio                     ra;</span><br><span class="line"></span><br><span class="line">    video/3gpp                            3gpp 3gp;</span><br><span class="line">    video/mp2t                            ts;</span><br><span class="line">    video/mp4                             mp4;</span><br><span class="line">    video/mpeg                            mpeg mpg;</span><br><span class="line">    video/quicktime                       mov;</span><br><span class="line">    video/webm                            webm;</span><br><span class="line">    video/x-flv                           flv;</span><br><span class="line">    video/x-m4v                           m4v;</span><br><span class="line">    video/x-mng                           mng;</span><br><span class="line">    video/x-ms-asf                        asx asf;</span><br><span class="line">    video/x-ms-wmv                        wmv;</span><br><span class="line">    video/x-msvideo                       avi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>Trojan目前的客户端只是socks5代理，Chrome浏览器需要配合<code>SwitchyOmega</code>使用；</li>
<li>相对于SS使用加密模式，Trojan最大的不同是 <strong>伪装</strong> 成普通的HTTPS流量实现过墙。</li>
<li><a href="https://www.vpsss.net/6281.html">检查是否被封的方法</a></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.v2rayssr.com/trojan-1.html">波仔</a></li>
<li><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">gfwlist</a></li>
<li><a href="https://blog.csdn.net/Muxi_k/article/details/104393009">nginx启动找不到mime.types</a></li>
<li><a href="https://vickey.fun/2022/03/22/auto-deploy-ssl-certificate-using-acme-sh/">acme证书问题</a></li>
</ul>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>Trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo algolia文章过长报错的解决方法</title>
    <url>/post/4a3fe015.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍当文章过长，执行<code>hexo algolia</code>时报错<code>AlgoliaSearchError: Record at the position ... is too big size</code>的解决方法.</p>
<span id="more"></span>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>找到<code>command.js</code>这个文件，将<code>var storedPost =</code>这一句做以下替换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// var storedPost = _.pick(data, [&#x27;title&#x27;, &#x27;date&#x27;, &#x27;slug&#x27;, &#x27;path&#x27;, &#x27;content&#x27;, &#x27;excerpt&#x27;, &#x27;objectID&#x27;]);</span><br><span class="line">            var storedPost = _.pick(data, [&#x27;title&#x27;, &#x27;date&#x27;, &#x27;slug&#x27;, &#x27;path&#x27;, &#x27;objectID&#x27;]);</span><br></pre></td></tr></table></figure>
<p>上面注释掉的就是原来的，虽然这种方法有弊端，不过其他的也没找到啥好方法。</p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题去掉码市的Coding Pages等待页</title>
    <url>/post/2dde9ec2.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍去除码市的Coding Pages的<a href="https://coding.net/u/coding/p/Coding-Feedback/topic/337715">等待跳转页</a>的方法,采用hexo的next主题5.1.2版本.</p>
<span id="more"></span>
<h2 id="1-升级银牌会员"><a href="#1-升级银牌会员" class="headerlink" title="1.升级银牌会员"></a>1.升级银牌会员</h2><p>完善信息就ok，这一步是必须的。</p>
<h2 id="2-修改footer-swig"><a href="#2-修改footer-swig" class="headerlink" title="2.修改footer.swig"></a>2.修改<code>footer.swig</code></h2><p>找到主题下的这个文件，找到这一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>原来这里面放的是<strong>主题 — NexT.Pisces v5.1.2</strong>，如下图所示:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170902-112355.jpg" alt=""><br>其实这个没什么卵用，将这个div的东西都删掉，然后添加一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>最后完整的尾部信息是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.copyright %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;span&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170902-112742.jpg" alt=""><br>既保证了原来的结构也达到了效果。之前曾尝试过在copyright也就是博主名后面加(参考链接1的方案)弄两个竖线，但是又对不齐无奈太丑了所以放弃.</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/yingpaixiaochuan/article/details/77113397">http://blog.csdn.net/yingpaixiaochuan/article/details/77113397</a></li>
<li><a href="http://zhanghao.studio/%E6%8F%90%E5%8D%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6.html">http://zhanghao.studio/%E6%8F%90%E5%8D%87%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6.html</a></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题集成gitment评论系统</title>
    <url>/post/ab9bb85a.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍hexo next主题(5.1.2)集成giment评论系统的过程。所谓gitment就是把评论放到github的issues系统里，评论支持md，比较适合程序员.</p>
<span id="more"></span>
<h2 id="一-注册OAuth-Application"><a href="#一-注册OAuth-Application" class="headerlink" title="一.注册OAuth Application"></a>一.注册OAuth Application</h2><p>点击<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a>注册，注意<code>Authorization callback URL</code>填自己的网站url<code>http://yangq.me/</code>.记下<strong>Client ID</strong>和<strong>Client Secret</strong>.</p>
<h2 id="二-修改themes-next-config-yml"><a href="#二-修改themes-next-config-yml" class="headerlink" title="二.修改themes/next/_config.yml"></a>二.修改<code>themes/next/_config.yml</code></h2><p>在其中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: yourid</span><br><span class="line">  repo: yourrepo</span><br><span class="line">  ClientID: yourid</span><br><span class="line">  ClientSecret: yoursecret</span><br><span class="line">  lazy: true</span><br></pre></td></tr></table></figure>
<p><strong>注意:格式要正确，该空格的一定要空格。所有的yourXXX都换成自己的.</strong></p>
<p>在主题的<code>en.yml</code>增加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitmentbutton: Show comments from Gitment</span><br></pre></td></tr></table></figure>

<p><code>zh-Hans.yml</code>增加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示 Gitment 评论</span><br></pre></td></tr></table></figure>

<h2 id="三-修改主题layout-partials-comments-swig"><a href="#三-修改主题layout-partials-comments-swig" class="headerlink" title="三.修改主题layout/_partials/comments.swig"></a>三.修改主题<code>layout/_partials/comments.swig</code></h2><p>找到这个文件里的这两行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">      &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>上面是最后一个<code>elseif</code>分支，在下面加一个<code>elseif</code>分支:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">     &lt;div onclick=&quot;ShowGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123;  __(&#x27;gitmentbutton&#x27;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">     &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">     &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">   &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>加完之后下面的内容是原来的，保持不变:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-增加gitment-swig"><a href="#四-增加gitment-swig" class="headerlink" title="四.增加gitment.swig"></a>四.增加<code>gitment.swig</code></h2><p>在主题下<code>layout/_third-party/comments/</code>目录下中添加文件<code>gitment.swig</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner = theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo = theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid = theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs = theme.gitment.ClientSecret %&#125;</span><br><span class="line">   &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">           var gitment = new Gitment(&#123;</span><br><span class="line">               id: window.location.pathname, </span><br><span class="line">               owner: &#x27;&#123;&#123;owner&#125;&#125;&#x27;,</span><br><span class="line">               repo: &#x27;&#123;&#123;repo&#125;&#125;&#x27;,</span><br><span class="line">               oauth: &#123;</span><br><span class="line">                   client_id: &#x27;&#123;&#123;cid&#125;&#125;&#x27;,</span><br><span class="line">                   client_secret: &#x27;&#123;&#123;cs&#125;&#125;&#x27;,</span><br><span class="line">               &#125;&#125;);</span><br><span class="line">           gitment.render(&#x27;gitment-container&#x27;);</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">           function ShowGitment()&#123;</span><br><span class="line">               document.getElementById(&quot;gitment-display-button&quot;).style.display = &quot;none&quot;;</span><br><span class="line">               document.getElementById(&quot;gitment-container&quot;).style.display = &quot;block&quot;;</span><br><span class="line">               var gitment = new Gitment(&#123;</span><br><span class="line">                   id: document.location.href, </span><br><span class="line">                   owner: &#x27;&#123;&#123;owner&#125;&#125;&#x27;,</span><br><span class="line">                   repo: &#x27;&#123;&#123;repo&#125;&#125;&#x27;,</span><br><span class="line">                   oauth: &#123;</span><br><span class="line">                       client_id: &#x27;&#123;&#123;cid&#125;&#125;&#x27;,</span><br><span class="line">                       client_secret: &#x27;&#123;&#123;cs&#125;&#125;&#x27;,</span><br><span class="line">                   &#125;&#125;);</span><br><span class="line">               gitment.render(&#x27;gitment-container&#x27;);</span><br><span class="line">           &#125;</span><br><span class="line">       &lt;/script&gt;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>layout/_third-party/comments/index.swig</code>文件中引入gitment.swig文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% include &#x27;gitment.swig&#x27; %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-添加gitment-styl"><a href="#五-添加gitment-styl" class="headerlink" title="五.添加gitment.styl"></a>五.添加<code>gitment.styl</code></h2><p>在主题下<code>source/css/_common/components/third-party/</code>目录下添加<code>gitment.styl</code>文件，设置button的样式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#gitment-display-button&#123;</span><br><span class="line">     display: inline-block;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     color: #0a9caf;</span><br><span class="line">     cursor: pointer;</span><br><span class="line">     font-size: 14px;</span><br><span class="line">     border: 1px solid #0a9caf;</span><br><span class="line">     border-radius: 4px;</span><br><span class="line"> &#125;</span><br><span class="line"> #gitment-display-button:hover&#123;</span><br><span class="line">     color: #fff;</span><br><span class="line">     background: #0a9caf;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>source/css/_common/components/third-party/third-party.styl</code>文件中引入相应的CSS样式即可:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure>
<p>这样就ok了！</p>
<h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><ol>
<li>修改<code>themes/next/_config.yml</code>这个文件时，格式要正确。另外，repo是你要想创建issues的仓库，完全可以跟博文所放的仓库不一个。id就写自己的github用户名就可以，这个用户名跟repo必须匹配。</li>
<li>gitment可能不支持链接地址里有中文，所以安装gitment前一定要参考<a href="http://yangq.me/post/19acb239.html">前文</a>把链接持久化搞成全是英文的。</li>
<li>同一篇文章需要<a href="https://github.com/imsun/gitment/issues/68">初始化comment两次的问题</a>，是因为<a href="http://xxx.com/post/ab9bb85a.html">http://xxx.com/post/ab9bb85a.html</a>和点击<strong>阅读全文</strong>进去的链接<a href="http://yangq.me/post/ab9bb85a.html#more">http://xxx.com/post/ab9bb85a.html#more</a>对issues来说是不同的，所以创建两次。解决方法就是<code>gitment.swig</code>里id弄成<code>window.location.pathname</code>而不是<code>document.location.href</code>。</li>
<li>初始化评论后，可以到github里自己放issues的仓库查看issues是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://www.jianshu.com/p/10134c474991">主要参考文档</a></li>
<li><a href="https://meesong.github.io/StaticBlog/2017/NexT+Gitment/">一种相对简略的配置方式</a></li>
<li><a href="https://github.com/imsun/gitment/issues">作者issue</a></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo配置汇总</title>
    <url>/post/b4cfac7b.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍hexo使用、维护、升级配置汇总，theme为<a href="http://theme-next.iissnan.com/getting-started.html">next-theme</a>。</p>
<span id="more"></span>
<h2 id="升级hexo从3-8-0至3-9-0"><a href="#升级hexo从3-8-0至3-9-0" class="headerlink" title="升级hexo从3.8.0至3.9.0"></a>升级<a href="https://hexo.io/zh-cn/">hexo</a>从3.8.0至3.9.0</h2><p>升级前运行<code>hexo version</code>查看版本信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hexo git:(master) hexo version</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Darwin 18.6.0 darwin x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.15.3</span><br><span class="line">v8: 6.8.275.32-node.51</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.15.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0j</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure>

<ul>
<li><p>升级hexo-cli<br>执行：<code>sudo npm install hexo-cli -g</code></p>
</li>
<li><p>升级hexo<br>执行：<code>npm install hexo --save</code><br>升级之后可以手动将<code>package.json</code>里的hexo对应version改下。执行完毕后如下：<br><img src="https://i.loli.net/2019/09/15/KpG73UQxoSfqB4A.png" alt="WX20190915-184353@2x.png"></p>
</li>
<li><p>升级<code>package.json</code>其他依赖，这个方法有三种：</p>
</li>
</ul>
<ol>
<li><p>手工更新(先改package里的版本号)<br>在<a href="http://npm.taobao.org/package/hexo-deployer-git">http://npm.taobao.org/package/hexo-deployer-git</a>里手动检查每个dependencies，如<code>hexo-deployer-git</code>本来版本号是<code>^0.3.1</code>是没法升到最新的<code>2.0.0</code>的。手动修改<code>package.json</code>里的hexo-deployer-git为<code>^2.0.0</code>,然后输入:<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>手工更新(npm update命令)<br><code>npm update hexo-deployer-git@2.0.0 --save</code><br>或者:<code>npm update hexo-deployer-git@latest --save</code></p>
</li>
<li><p>通过<code>npm-check-updates</code><br>执行：<code>npm install -g npm-check-updates</code>安装，之后ncu就是这个命令缩写。<br>执行：<code>ncu</code>检查更新如下：<br><img src="https://i.loli.net/2019/09/15/D2I8sPj5Lt6TVQC.png" alt="WX20190915-193209@2x.png"></p>
</li>
</ol>
<p>执行：<code>ncu -u</code>更新package.json文件：<br><img src="https://i.loli.net/2019/09/15/UuObE5QXR6psYeG.png" alt="WX20190915-193659@2x.png"></p>
<p>最后通过<code>npm install</code>安装更新。</p>
<h2 id="升级hexo-next-theme从7-1-0至7-4-0"><a href="#升级hexo-next-theme从7-1-0至7-4-0" class="headerlink" title="升级hexo-next-theme从7.1.0至7.4.0"></a>升级<a href="http://theme-next.iissnan.com/getting-started.html">hexo-next-theme</a>从7.1.0至<a href="https://github.com/theme-next/hexo-theme-next">7.4.0</a></h2><h3 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h3><p>参考<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/INSTALLATION.md">官网安装指导</a>，选择方式1，在hexo博客根目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1`</span><br></pre></td></tr></table></figure>

<h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>如果自己的头像使用git仓文件的话，将对应图片如<code>avatar.jpg</code>放在next的images文件夹下，随后在下面的配置里设上。</p>
<h3 id="解耦个性化配置"><a href="#解耦个性化配置" class="headerlink" title="解耦个性化配置"></a>解耦个性化配置</h3><p><strong>hexo3.5以上</strong>版本next-theme的配置文件都在自己主题下的_config.yml，为了让个性化配置和源码里解耦方便后续升级主题，新建<code>source/_data/next.yml</code>，内容从<code>next/_config.yml</code>里完整拷贝过来。同时在默认的<code>next/_config.yml</code>里将<code>override: false</code>，表示如果有冲突时会merge自定义的<code>next.yml</code>和默认的<code>_config.yml</code>，以<code>next.yml</code>为准。这样<code>next.yml</code>只保留自己个性化定制的东西即可。</p>
<ul>
<li>头像：<code>avatar</code>的URL字段设置为<code>images/avatar.jpg</code></li>
<li>个数统计，使用<code>busuanzi_count</code></li>
<li>gitalk评论</li>
<li><code>Menu Settings</code></li>
<li><code>Scheme Settings</code></li>
<li><code>footer</code>设置since和icon</li>
</ul>
<h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>升到最新的7.4.0后发现字体特别大不好看，修改font settings使用Noto Serif SC思源宋体大小为默认的0.8刚刚好：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  # Use custom fonts families or not.</span><br><span class="line">  # Depended options: `external` and `family`.</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. //fonts.googleapis.com (Default).</span><br><span class="line">  host: https://fonts.loli.net</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # `external: true` will load this font family from `host` above.</span><br><span class="line">  # `family: Times New Roman`. Without any quotes.</span><br><span class="line">  # `size: x.x`. Use `em` as unit. Default: 1 (16px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used for all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Noto Serif SC</span><br><span class="line">    size: 0.8</span><br></pre></td></tr></table></figure>

<h3 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h3><p>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: night bright </span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: default</span><br></pre></td></tr></table></figure>

<p>然后还要将<code>https://github.com/chriskempson/tomorrow-theme.git</code>拷贝到<code>theme/next/source/lib</code>下才会生效。</p>
<h3 id="CNAME解决github-404问题"><a href="#CNAME解决github-404问题" class="headerlink" title="CNAME解决github 404问题"></a><code>CNAME</code>解决github 404问题</h3><p>需要在主题的<code>themes/next_7.4.0/source</code>的目录下新建 <strong>CNAME</strong> 文件，内容为自己的域名，本文为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yangq.me</span><br></pre></td></tr></table></figure>
<p>否则每次push到github后，将会遇到404问题。然后需要在github的仓pages设置里把域名设进去。下次push后又会遇到404问题，需要再次设置。通过<code>CNAME</code>文件解决此问题。</p>
<h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>之前一直使用的Algolia，但是发现不太好用，一段时间之后再搜索就不灵了。这次采用的是<a href="http://theme-next.iissnan.com/third-party-services.html#local-search">Local Search </a>，简单好用而且不收费。</p>
<ul>
<li><p>安装<code>hexo-generator-searchdb</code>，站点根目录下执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li><p>然后站点配置文件新增:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑主题配置文件，启用本地搜索功能:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/david_shangyin/article/details/83688674">npm 更新package.json</a></li>
<li><a href="https://blog.csdn.net/colton_null/article/details/97622079">Hexo Theme NexT 主题个性化配置最佳实践</a></li>
<li><a href="https://sxxkearth.github.io/2019/01/09/Next%E5%AD%97%E4%BD%93%E4%BF%AE%E6%94%B9/">Next修改字体</a></li>
</ul>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo链接持久化终极解决之道</title>
    <url>/post/19acb239.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>大家知道hexo默认的链接是<code>http://xxx.yy.com/2013/07/14/hello-world</code>这种类型的，这源于站点目录下的配置<code>_config.yml</code>里的配置:<code>permalink: :year/:month/:day/:title/</code>.这种默认配置的缺点就是一般文件名是中文，导致url链接里有中文出现，这会造成很多问题，如使用gitment，也不利于seo。另外就是年月日都会有分隔符。本文介绍经过作者研究总结出的最终解决方案。</p>
<span id="more"></span>

<h2 id="过时解决方案"><a href="#过时解决方案" class="headerlink" title="过时解决方案"></a><del>过时解决方案</del></h2><p>在md文件的<code>Front-matter</code>区域，增加一个urlname属性，用来放文章的英文名字。如下图所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: hexo链接持久化终极解决之道</span><br><span class="line">urlname: hexo_permalink</span><br><span class="line">date: 2017-08-31 23:53:24</span><br><span class="line">comments: true</span><br><span class="line">categories:</span><br><span class="line">- 综合</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br></pre></td></tr></table></figure>
<p>然后修改<br><code>_config.yml</code>里的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: posts/:category/:year:month:day-:urlname.html</span><br><span class="line">permalink_defaults:</span><br><span class="line">  urlname: index</span><br></pre></td></tr></table></figure>
<p>后缀增加<code>.html</code>给人以静态页面感觉，利于seo.这里面<code>:urlname</code>表示引用的这个变量。前面是分类／年月日。另外增加一个urlname这个属性的默认值，当md文档里不填这个属性，就用这个值。这里设的是<code>index</code>,也就是说如果不填这个属性,其链接为:<code>http://xxx.com/posts/uncategorized/20170828-index.html</code>。当然最好写上这个属性，偶尔某天不写这个属性也没关系。</p>
<p>另外还要解决一个问题，就是<code>:category</code>分类有可能为中文。为此在站点下配置文件里设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">  综合: common</span><br></pre></td></tr></table></figure>
<p>这样在<code>Front-matter</code>里，分类该写中文写中文，最终的链接会翻译成英文。</p>
<h2 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h2><p>无意中看到<a href="http://muyunyun.cn/posts/f55182c5/#more">http://muyunyun.cn/posts/f55182c5/#more</a>,最终决定采用这种方案使用<code>hexo-abbrlink</code>这个插件，猜测是根据时间点算出的最终链接,后期不管怎么修改永久链接都不会变.一来自己不用再增加什么属性了，也不用考虑分类中文化的问题。二来后面的层级更短，更利于SEO。(一般SEO只爬三层)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>站点配置文件里:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: post/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>

<p>另外可以修改<code>scaffolds</code>里的模版文件，修改<code>post.md</code>为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">comments: true</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="不建议的写法"><a href="#不建议的写法" class="headerlink" title="不建议的写法"></a>不建议的写法</h2><ol>
<li>有的人采用了md文件的名字是英文，在<code>Front-matter</code>里将<code>title</code>写成正常的中文呢，这个将来文章多了，都是英文不利于收藏整理。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://hexo.io/zh-cn/docs/permalinks.html">https://hexo.io/zh-cn/docs/permalinks.html</a></li>
<li><a href="https://yq.aliyun.com/articles/8607">https://yq.aliyun.com/articles/8607</a></li>
<li><a href="http://muyunyun.cn/posts/f55182c5/#more">http://muyunyun.cn/posts/f55182c5/#more</a></li>
<li><a href="http://blog.csdn.net/mrDiordna/article/details/66472673">http://blog.csdn.net/mrDiordna/article/details/66472673</a></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>V2Ray纪要</title>
    <url>/post/186c438c.html</url>
    <content><![CDATA[<p>本文介绍V2Ray科学上网新姿势。</p>
<span id="more"></span>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>以下所有命令均需要以root权限进行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://install.direct/go.sh</span><br><span class="line">chmod +x go.sh</span><br><span class="line">bash go.sh</span><br></pre></td></tr></table></figure>
<p>查看配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim  /etc/v2ray/config.json</span><br></pre></td></tr></table></figure>
<p>记下<strong>inbounds</strong>里的<strong>port</strong>、clients里的id和alterId三个变量即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;inbounds&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;port&quot;: 8012,</span><br><span class="line">                        &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">                        &quot;settings&quot;: &#123;</span><br><span class="line">                                &quot;clients&quot;: [</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                &quot;id&quot;: &quot;4f89d776-4ba8-4d5d-a211-9db5a948***&quot;,</span><br><span class="line">                                                &quot;level&quot;: 1,</span><br><span class="line">                                                &quot;alterId&quot;: 233</span><br><span class="line">                                        &#125;</span><br><span class="line">                                ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                                &quot;streamSettings&quot;: &#123;</span><br><span class="line">                                &quot;wsSettings&quot;:&#123;</span><br><span class="line">                                &quot;path&quot;:&quot;/&quot;,</span><br><span class="line">                                &quot;headers&quot;:&#123;&#125;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;network&quot;: &quot;tcp&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;sniffing&quot;: &#123;</span><br><span class="line">                                &quot;enabled&quot;: true,</span><br><span class="line">                                &quot;destOverride&quot;: [</span><br><span class="line">                                        &quot;http&quot;,</span><br><span class="line">                                        &quot;tls&quot;</span><br><span class="line">                                ]</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //include_ss</span><br><span class="line">                //include_socks</span><br><span class="line">                //include_mtproto</span><br><span class="line">                //include_in_config</span><br><span class="line">                //</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p>其中的id、alterId、port及协议类型vmess需要和客户端对应，尤其是streamSettings里的network，这里是tcp也需要和客户端对应。</p>
<h2 id="客户端-Mac"><a href="#客户端-Mac" class="headerlink" title="客户端(Mac)"></a>客户端(Mac)</h2><p>本文介绍三种安装方式，推荐使用带图形界面的第三种方式。无论哪种方式对客户端来说把<strong>outbounds</strong>配置好就行了，该字段又对应服务端的<strong>inbounds</strong>。</p>
<h3 id="1-brew方式安装"><a href="#1-brew方式安装" class="headerlink" title="1.brew方式安装"></a>1.brew方式安装</h3><p><a href="https://github.com/v2ray/homebrew-v2ray">https://github.com/v2ray/homebrew-v2ray</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap v2ray/v2ray</span><br><span class="line">brew install v2ray-core</span><br><span class="line">brew update</span><br><span class="line">brew upgrade v2ray-core</span><br><span class="line">brew uninstall v2ray-core</span><br></pre></td></tr></table></figure>
<p>修改配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /usr/local/etc/v2ray/config.json</span><br><span class="line">brew services run v2ray-core</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>brew services start v2ray-core</code>开机运行v2ray。</p>
<h3 id="2-二进制安装"><a href="#2-二进制安装" class="headerlink" title="2.二进制安装"></a>2.二进制安装</h3><p><a href="https://github.com/v2ray/dist/">https://github.com/v2ray/dist/</a><br>缺点是要自己手动启动，并修改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;outbounds&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;protocol&quot;: &quot;vmess&quot;, // 出口协议</span><br><span class="line">     &quot;settings&quot;: &#123;</span><br><span class="line">       &quot;vnext&quot;: [</span><br><span class="line">         &#123;</span><br><span class="line">           &quot;address&quot;: &quot;67.218.**.**&quot;, // 服务器地址，请修改为你自己的服务器 IP 或域名</span><br><span class="line">           &quot;port&quot;: 41254,  // 服务器端口</span><br><span class="line">           &quot;users&quot;: [</span><br><span class="line">             &#123;</span><br><span class="line">               &quot;id&quot;: &quot;4f89d776-4ba8-4d5d-a211-9db5a94*****&quot;,  // 用户 ID，必须与服务器端配置相同</span><br><span class="line">               &quot;alterId&quot;: 233// 此处的值也应当与服务器相同</span><br><span class="line">             &#125;</span><br><span class="line">           ]</span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>
<h3 id="3-GUI软件-Android、iOS、Mac、Windows"><a href="#3-GUI软件-Android、iOS、Mac、Windows" class="headerlink" title="3.GUI软件(Android、iOS、Mac、Windows)"></a>3.GUI软件(Android、iOS、Mac、Windows)</h3><p>参考<a href="https://www.v2ray.com/awesome/tools.html">v2ray神一样的工具</a>,我使用的是<a href="https://github.com/Cenmrev/V2RayX">V2RayX</a>,下载后直接配置就好。<br><img src="https://i.loli.net/2019/07/14/5d2b2c41a273358931.png" alt="WX20190714-211756@2x.png"><br>重点关注红框里的信息，其中Address、Port、UserId、alterId、Network需要和服务端的<strong>inbounds</strong>字段严格对应。</p>
<p>其他平台:</p>
<ol>
<li><a href="https://github.com/Cenmrev/V2RayW">V2RayW-windows</a></li>
<li><a href="https://apkpure.com/kitsunebi/fun.kitsunebi.kitsunebi4android">Kitsunebi-Android</a></li>
</ol>
<h2 id="websocket-tls-web"><a href="#websocket-tls-web" class="headerlink" title="websocket+tls+web"></a>websocket+tls+web</h2><p>通过上面的配置安装已经可以实现科学上网了，下面介绍把CDN也加上实现更安全的方式。需要买一个域名并配置dns转发到目的IP。这样所有科学上网的端侧请求目的不再是IP，而是一个域名，经过转发后才访问对应的目的I，最终实现被墙了的IP也能访问的目的。要实现这一步你需要有以下几个东西：</p>
<ul>
<li>一个域名，可以在<a href="https://www.namesilo.com/">https://www.namesilo.com/ </a>购买更便宜。</li>
<li>一个CDN中转解析域名的东西，推荐使用<a href="https://www.cloudflare.com/">https://www.cloudflare.com/</a></li>
<li>一个墙外的VPS,在上面搭建好v2ray</li>
<li>VPS上安装Caddy或Nginx,实现Web+TLS</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://toutyrater.github.io/prep/install.html">https://toutyrater.github.io/prep/install.html</a></li>
<li><a href="https://www.v2ray.com/">官网教程</a></li>
<li><a href="https://blog.sprov.xyz/2019/03/11/cdn-v2ray-safe-proxy/">v2ray+CloudFlare</a></li>
<li><a href="https://www.conum.cn/share/191.html">基于v2ray的websocket+tls+web实现安全网络代理</a></li>
<li><a href="https://www.jianshu.com/p/e727cd971f55">debian8开启BBR</a></li>
<li><a href="https://raw.githubusercontent.com/233boy/v2ray/master/install.sh">233body</a></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>免费tj机场</title>
    <url>/post/1f260d72.html</url>
    <content><![CDATA[<p>本文介绍墙外失联后使用免费tj机场。</p>
<span id="more"></span>

<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p><a href="https://goii.cc/jisu">极速max</a></p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈Mac上Privoxy实现socks5转http(附High Sierra上privoxy启动不了问题的解决)</title>
    <url>/post/c75a2f22.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Privoxy是一个可以将socks5道理转成http代理的东西，弥补很多三方软件无法直接走socks5流量的缺点。之前Mac上Privoxy一直都工作的好好的，但是后来不能用了，本文介绍Mac上(High Sierra版本)Privoxy启动不了的问题。</p>
<span id="more"></span>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>出现问题后，试了很多种方法，包括卸载重装等，一直都无效，Privoxy根本起不起来。最后迷瞪过来，是因为我把Mac升级到了<code>High Sierra</code>但是Xcode还停留在老版本的原因。所以各位如果你升级了Mac大版本一定要记得升级XCode。下面介绍用<code>Brew</code>安装Privoxy的方法，所有操作都是升级XCode后进行的。</p>
<h2 id="Brew安装Privoxy"><a href="#Brew安装Privoxy" class="headerlink" title="Brew安装Privoxy"></a>Brew安装Privoxy</h2><p>输入命令:<code>brew install privoxy</code>就ok了。之后修改配置文件<code>/usr/local/etc/privoxy/config</code>,搜索<code>socks5</code>找到下面这一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#forward-socks5t   /               127.0.0.1:9050 .</span><br></pre></td></tr></table></figure>
<p>其中9050是Tor浏览器提供的本地socks5端口，这句不用管，直接在下面加一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forward-socks5   /               127.0.0.1:1080 .</span><br></pre></td></tr></table></figure>
<p>这里1080是本地socks5的端口，记住最后面有一个点号不能少.<br>另外还能看到默认的一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address 127.0.0.1:8118</span><br></pre></td></tr></table></figure>
<p>这表示privoxy只兼听本机的8118端口，如果你希望其他局域网内都可以用这个代理可以修改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen-address 0.0.0.0:8118</span><br></pre></td></tr></table></figure>
<h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>之前从来没有设置过开机自启，都是需要用到时才用脚本去启动，现在来看太麻烦了。完全可以让他开机启动，用到时去接到8118端口就可以了。<br>用brew安装完毕后，会看到下面一段话:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt; Installing privoxy</span><br><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/privoxy-3.0.26.high_sierra.</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Pouring privoxy-3.0.26.high_sierra.bottle.1.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">To have launchd start privoxy now and restart at login:</span><br><span class="line">  brew services start privoxy</span><br><span class="line">Or, if you don&#x27;t want/need a background service you can just run:</span><br><span class="line">  privoxy /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure>
<p>如果想设置开机启动的话，只需要:<code>sudo brew services start privoxy</code>就ok了。如果单次启动的话用<code>/usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code>。<br><strong>备注:这个启动方式和用<a href="https://www.privoxy.org">Privxoy</a>原始安装方式还是有区别的。</strong></p>
<h2 id="验证是否启动"><a href="#验证是否启动" class="headerlink" title="验证是否启动"></a>验证是否启动</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>经过上述操作打开shadowsocks和privoxy后，就需要验证socks5代理转http是否成功。首先看privoxy是否启动起来了,输入<code>ps -ef|grep privoxy</code>可以看到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">501   400     1   0  4:58下午 ??         0:00.18 /usr/local/Cellar/privoxy/3.0.26/sbin/privoxy --no-daemon /usr/local/etc/privoxy/config</span><br><span class="line">501   402     1   0  4:58下午 ??         0:00.01 /Users/yanzi/Library/Application Support/ShadowsocksX-NG/privoxy --no-daemon privoxy.config</span><br><span class="line">501  1625  1600   0  6:46下午 ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn privoxy</span><br></pre></td></tr></table></figure>
<p>可以看到已经启动成功了。</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>输入<code>netstat -an | grep 8118</code>可以看到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp4       0      0  127.0.0.1.8118         *.*                    LISTEN</span><br></pre></td></tr></table></figure>
<p>也能证明已经ok了。 </p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>最根本的方法莫过于通过8118端口访问google了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -e http_proxy=127.0.0.1:8118 www.google.com</span><br><span class="line">curl -x 127.0.0.1:8118 www.google.com</span><br></pre></td></tr></table></figure>
<p>用wget和curl都是ok的。</p>
<h2 id="终端也能用代理"><a href="#终端也能用代理" class="headerlink" title="终端也能用代理"></a>终端也能用代理</h2><p>在<code>~/.zshrc</code>里加上两句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=&#x27;http://127.0.0.1:8118&#x27;</span><br><span class="line">export https_proxy=&#x27;http://127.0.0.1:8118&#x27;</span><br></pre></td></tr></table></figure>
<p>通过<code>echo $http_proxy</code>要确保其生效,此时在console里wget Google的话就不需要指定代理也能出去了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://segmentfault.com/a/1190000008848001">https://segmentfault.com/a/1190000008848001</a></li>
<li><a href="https://www.privoxy.org/user-manual/quickstart.html">官方quickstart</a></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Node.js至8.0后hexo报错的解决</title>
    <url>/post/635ec9a4.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文介绍升级Node.js至8.0后使用hexo新建文章过程中报各种异常的解决方法.</p>
<span id="more"></span>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>hexo新建文章时报一堆异常:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&#x27;</span><br><span class="line">was compiled against a different Node.js version using</span><br><span class="line">NODE_MODULE_VERSION 46. This version of Node.js requires</span><br><span class="line">NODE_MODULE_VERSION 57</span><br></pre></td></tr></table></figure>
<p>这个<strong>DTraceProviderBindings.node</strong>一直报错，跟<strong>hexo-fs</strong>有关。</p>
<p>此外使用<code>hexo clean --debug</code>时能看到如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  hexo git:(master) ✗ hexo clean --debug</span><br><span class="line">14:07:03.119 DEBUG Hexo version: 3.3.8</span><br><span class="line">14:07:03.122 DEBUG Working directory: ~/work/hexo/</span><br><span class="line">14:07:03.243 DEBUG Config loaded: ~/work/hexo/_config.yml</span><br><span class="line">14:07:03.486 DEBUG Plugin loaded: hexo-abbrlink</span><br><span class="line">14:07:03.524 DEBUG Plugin loaded: hexo-util</span><br><span class="line">14:07:03.792 DEBUG Plugin loaded: hexo-deployer-git</span><br><span class="line">(node:25070) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br><span class="line">14:07:03.846 DEBUG Plugin loaded: hexo-algolia</span><br><span class="line">14:07:03.851 DEBUG Plugin loaded: hexo-generator-archive</span><br><span class="line">14:07:03.854 DEBUG Plugin loaded: hexo-generator-category</span><br><span class="line">14:07:03.858 DEBUG Plugin loaded: hexo-generator-tag</span><br><span class="line">14:07:03.862 DEBUG Plugin loaded: hexo-fs</span><br><span class="line">14:07:03.867 DEBUG Plugin loaded: hexo-generator-index</span><br><span class="line">14:07:03.873 DEBUG Plugin loaded: hexo-renderer-ejs</span><br><span class="line">14:07:04.019 DEBUG Plugin loaded: hexo-server</span><br><span class="line">14:07:04.020 DEBUG Plugin loaded: hexo-renderer-stylus</span><br><span class="line">14:07:04.040 DEBUG Plugin loaded: hexo-renderer-marked</span><br><span class="line">14:07:04.043 DEBUG Script loaded: themes/next/scripts/merge-configs.js</span><br><span class="line">14:07:04.043 DEBUG Script loaded: themes/next/scripts/tags/button.js</span><br><span class="line">14:07:04.078 DEBUG Script loaded: themes/next/scripts/tags/exturl.js</span><br><span class="line">14:07:04.079 DEBUG Script loaded: themes/next/scripts/tags/center-quote.js</span><br><span class="line">14:07:04.083 DEBUG Script loaded: themes/next/scripts/merge.js</span><br><span class="line">14:07:04.083 DEBUG Script loaded: themes/next/scripts/tags/full-image.js</span><br><span class="line">14:07:04.084 DEBUG Script loaded: themes/next/scripts/tags/label.js</span><br><span class="line">14:07:04.084 DEBUG Script loaded: themes/next/scripts/tags/lazy-image.js</span><br><span class="line">14:07:04.085 DEBUG Script loaded: themes/next/scripts/tags/note.js</span><br><span class="line">14:07:04.085 DEBUG Script loaded: themes/next/scripts/tags/group-pictures.js</span><br><span class="line">14:07:04.086 DEBUG Script loaded: themes/next/scripts/tags/tabs.js</span><br><span class="line">14:07:04.088 INFO  Deleted database.</span><br><span class="line">14:07:04.090 DEBUG Database saved</span><br></pre></td></tr></table></figure>
<p>可以看到<strong>hexo-deployer-git</strong>这个module用了一个废弃的方法.</p>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>原因是Node.js从6.0的版本升到8.10.0后，老的module不兼容了，我们只需要升级module就好了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>参考<a href="http://yangbingdong.com/2017/build-blog-hexo-base/">http://yangbingdong.com/2017/build-blog-hexo-base/</a>并没有解决问题。最终我的解决方法如下:</p>
<ol>
<li>重装<code>hexo-cli</code><br>执行命令<code>npm install hexo-cli -g</code>安装最新版本的<a href="https://www.npmjs.com/package/hexo-cli">hexo-cli</a>，版本为1.1.0.</li>
<li>之后使用<code>hexo clean --debug</code>观察出错的module,从<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>查到最新版本，然后修改至package.json即可，需要改的有:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20180508-232414.jpg" alt=""><br>之后在博客根目录下执行<code>npm update</code>即可。最后通过<code>hexo version</code>可以查到对应版本:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  hexo git:(master) ✗ hexo version</span><br><span class="line">hexo: 3.3.8</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Darwin 17.4.0 darwin x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 8.10.0</span><br><span class="line">v8: 6.2.414.50</span><br><span class="line">uv: 1.19.1</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.25.0</span><br><span class="line">openssl: 1.0.2n</span><br><span class="line">icu: 60.1</span><br><span class="line">unicode: 10.0</span><br><span class="line">cldr: 32.0</span><br><span class="line">tz: 2017c</span><br></pre></td></tr></table></figure>
package.json如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;3.3.8&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;gitment&quot;: &quot;0.0.3&quot;,</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;hexo-abbrlink&quot;: &quot;^2.0.5&quot;,</span><br><span class="line">    &quot;hexo-algolia&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-fs&quot;: &quot;^0.2.3&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.2&quot;,</span><br><span class="line">    &quot;hexo-util&quot;: &quot;^0.6.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vultr Debian7上搭建科学上网，使用锐速畅享十倍提速</title>
    <url>/post/170b145.html</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前博文里有介绍过搭建科学上网环境后，使用锐速进行提速，但是加速的效果有时候觉得好，有时候觉得不行。最近帮朋友在vultr上申请一个IP，搭建环境后，发现同WIFI环境下新IP下载速度只有20-30KB，老IP能达到1M左右。在另一处wifi环境下，GooglePlay上下载应用老IP速度达2M左右，新IP只有400多kb。本来想给vultr提个ticket反馈下这个情况，最后想起来老IP上装了锐速，待新IP装上锐速后youtube速度竟飙到14M，有感与此详细记录此次折腾过程。服务器选择的是debian7 64位，所占内存很小，也不需要改防火墙端口，装锐速时也不需要换内核，比较方便。</p>
<span id="more"></span>
<h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><p>参考<a href="https://teddysun.com/342.html">博文</a>，运行如下命令安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>
<p>安装完毕后使用<code>service shadowsocks status</code>查看服务运行状态，执行<code>service shadowsocks restart|stop|start</code>对应重启、停止、启动该服务。</p>
<h2 id="创建多用户shadowsocks配置"><a href="#创建多用户shadowsocks配置" class="headerlink" title="创建多用户shadowsocks配置"></a>创建多用户shadowsocks配置</h2><p>这里交代一点，vultr的debian7上不需要像<a href="http://blog.csdn.net/yanzi1225627/article/details/51470962">CentOS上修改防火墙端口</a>.<br>多用户配置为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;your_encryption_method&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了批量创建端口号和对应的密码，我写了个python脚本，根据端口作出计算其对应的密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2017/8/21 下午10:56</span><br><span class="line"># @Author  : yanzi1225627</span><br><span class="line"># @Site    : </span><br><span class="line"># @File    : main.py</span><br><span class="line"># @Software: PyCharm Community Edition</span><br><span class="line"></span><br><span class="line">import _md5</span><br><span class="line">import hashlib</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getMd5(src):</span><br><span class="line">    m1 = hashlib.md5()</span><br><span class="line">    m1.update(str.encode(src))</span><br><span class="line">    return m1.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getPswdByPort(port):</span><br><span class="line">    data = port / 37 + 555</span><br><span class="line">    data1 = str(data) + &#x27;shadowsocks&#x27;</span><br><span class="line">    md = getMd5(data1)</span><br><span class="line">    return md[:6]</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    pswds = &#123;&#125;</span><br><span class="line">    for p in range(7000, 7020):</span><br><span class="line">        pswd = getPswdByPort(p)</span><br><span class="line">        # print(&quot;%s : %s&quot; % (str(p), pswd))</span><br><span class="line"></span><br><span class="line">        pswds.setdefault(str(p), pswd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(pswds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    config = &#123;</span><br><span class="line">        &quot;server&quot;:&quot;your ip&quot;,</span><br><span class="line">        &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">        &quot;local_port&quot;:1080,</span><br><span class="line">        &quot;port_password&quot;:pswds,</span><br><span class="line">        &quot;timeout&quot;:300,</span><br><span class="line">        &quot;method&quot;:&quot;rc4-md5&quot;,</span><br><span class="line">        &quot;fast_open&quot;:False</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    jsObj = json.dumps(config)</span><br><span class="line">    file= open(&#x27;./config.json&#x27;, &#x27;w&#x27;)</span><br><span class="line">    file.write(jsObj)</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="安装锐速"><a href="#安装锐速" class="headerlink" title="安装锐速"></a>安装锐速</h2><p>其加速的核心是<a href="http://www.appexnetworks.com.cn/tech/zetatcp-tec.html">zeta-tcp</a>,国外人最先提出来的，一种典型的单边加速，只需要在服务器部署即可。<br>首先执行<code>uname -a</code>查看内核如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux guest 3.2.0-4-amd64 #1 SMP Debian 3.2.89-2 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>可以看到其内核是<strong>debian的3.2.0-4-amd64</strong>，查看锐速支持的<a href="https://www.91yun.co/wp-content/plugins/91yun-serverspeeder/systemlist.html">内核列表</a>如下,可以看到在支持范围:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170825-234334.jpg" alt=""><br>所以就不用更换内核了。<br>运行如下脚本安装:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>
<p>卸载脚本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>
<p>安装完毕后，你需要知道几个命令:</p>
<p>几个相关命令:<br><code>service serverSpeeder status</code> 查看serverSpeeder的状态 </p>
<p><code>service serverSpeeder start | stop | restart</code> 停止暂停重启锐速<br>安装目录就在<code>/serverspeeder</code>,其配置文件路径:<code>/serverspeeder/etc/config</code>,基本按照默认配置就ok。</p>
<p>在youtube上搜索<code>1080p 测试视频</code>,如<a href="https://www.youtube.com/watch?v=Bey4XXJAqS8">https://www.youtube.com/watch?v=Bey4XXJAqS8</a>可以看到加速后速度飙到了40M左右，右边的<strong>TotalActiveTcpFlow</strong>这个数字用来检验锐速是否生效，越大越好。<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170825-235228.jpg" alt=""><br>关闭锐速后，其速度在3-4M左右，如下图:<br><img src="http://image.yangq.me/blog/history/16-7-5/Jietu20170825-235756.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文中用到的所有脚本已备份至<a href="https://github.com/yanzi1225627/greennet">github</a>,如果文中的链接或脚本被墙了，请到github里查看。<br><strong>如果本文对你有帮助且需要vultr的话，请点此<a href="https://www.vultr.com/?ref=6883272">我的推广</a>注册，我得优惠您得实惠～～～</strong></p>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>墙外失联终极解决方案</title>
    <url>/post/2fd5ac8d.html</url>
    <content><![CDATA[<p>本文介绍墙外失联后处理方法。</p>
<span id="more"></span>

<h2 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h2><p>Mac输入：<code>sudo vim /etc/hosts</code>然后新增一句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">104.20.200.21 free-ss.site</span><br></pre></td></tr></table></figure>

<p>其中：<br>第一位：104<br>第二位：16-31之间的一个数字<br>第三位：0-255<br>第四位：1-254<br>以上是为了访问<a href="https://free-ss.site/">https://free-ss.site/</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="mailto:ss@rohankdd.com">ss@rohankdd.com</a></li>
</ul>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
</search>
